#
# Control file template for Jet Set Willy
#
;
; SkoolKit control file for Jet Set Willy.
;
; Room descriptions based on reference material from Andrew Broad
; <http://webspace.webring.com/people/ja/andrewbroad/> and J. G. Harston
; <http://mdfs.net/Software/JSW/Docs/>.
;

; @start:32768
; @org:32768=32768
g 32768 Room buffer
D 32768 Initialised upon entry to a room by the routine at #R35068.
S 32768,128 Room layout (used by the routines at #R35068 and #R36203)
S 32896,32 Room name (used by the routine at #R35068)
S 32928,9 Background tile (used by the routines at #R36147, #R36288, #R36307 and #R38430, and also by the unused routine at #R37819)
S 32937,9 Floor tile (used by the routines at #R36147 and #R36288)
S 32946,9 Wall tile (used by the routines at #R36147, #R36288, #R36307 and #R36564)
S 32955,9 Nasty tile (used by the routines at #R36147, #R36288, #R36307 and #R38430)
S 32964,9 Ramp tile (used by the routines at #R36147, #R36203, #R36564 and #R38344)
S 32973,9 Conveyor tile (used by the routines at #R36147, #R36203 and #R36564)
S 32982,4 Conveyor definition (used by the routines at #R36564 and #R38137)
S 32986,4 Ramp definition (used by the routines at #R36203, #R36564 and #R38344)
B 32990,1 Border colour (used by the routines at #R35068, #R35591, #R36307, #R37310 and #R37841)
S 32991,2 Unused
S 32993,8 Item graphic (used by the routine at #R37841)
B 33001,1 Room to the left (used by the routine at #R38026)
B 33002,1 Room to the right (used by the routine at #R38046)
B 33003,1 Room above (used by the routines at #R37310 and #R38064)
B 33004,1 Room below (used by the routine at #R38098)
S 33005,3 Unused
S 33008,16 Entity specifications (used by the routine at #R35068)
g 33024 Entity buffer
D 33024 Used by the routines at #R35068, #R37056 and #R37310.
S 33024,64
B 33088 Terminator
s 33089
w 33280 Screen buffer address lookup table
D 33280 Used by the routines at #R35914, #R37310 and #R38455. The value of the Nth entry in this lookup table is the screen buffer address for the point with pixel coordinates (x,y)=(0,N), with the origin (0,0) at the top-left corner.
{sba_table}
b 33536 Rope animation table
D 33536 Used by the routine at #R37310.
B 33536,256,16
c 33792 The game has just loaded
D 33792 After the game has loaded, this is where it all starts.
  33792 Disable interrupts
  33793,11 Place the address of the routine at #R34463 on the stack
  33804,9 Set #REGhl=34048 in a roundabout way
  33813,10 Read through addresses 34048-65535, without changing their contents; perhaps this code was once used to descramble the contents of pages 133-255, but now all it does is introduce a pause of about 0.47s before displaying the code entry screen
  33823 Make an indirect jump to #R34463
g 33824 Current room number
D 33824 Used by the routines at #R34762, #R35068, #R35591, #R37310, #R37841, #R38026, #R38046, #R38064, #R38098, #R38196, #R38276, #R38298 and #R38455.
b 33825 Left-right movement table
D 33825 Used by the routine at #R36564.
b 33841 Triangle UDGs
D 33841 Used by the routine at #R34762.
D 33841 #UDGTABLE {{ #UDG33841,56(triangle0) | #UDG33849,56(triangle1) | #UDG33857,56(triangle2) | #UDG33865,56(triangle3) }} TABLE#
t 33873 'AIR'
D 33873 This message is not used.
t 33876 '+++++ Press ENTER to Start +++++...'
D 33876 Used by the routine at #R34762.
T 33908
T 33942,38,B1:37
T 33980
T 34024
T 34050
T 34100
t 34132 'Items collected 000 Time 00:00 m'
D 34132 Used by the routine at #R35068.
t 34164 'Game'
D 34164 Used by the routine at #R35914.
t 34168 'Over'
D 34168 Used by the routine at #R35914.
g 34172 Number of items collected
D 34172 Initialised by the routine at #R34762, printed by the routine at #R35245, and updated by the routine at #R37841.
T 34172
g 34175 Current time
D 34175 Initialised by the routine at #R35068, and printed and updated by the routine at #R35245.
T 34175
t 34181 ' 7:00a'
D 34181 Copied by the routine at #R35068 to #R34175.
t 34187 'Enter Code at grid location#SPACE5'
D 34187 Used by the routine at #R34463.
t 34219 'Sorry, try code at location#SPACE5'
D 34219 Used by the routine at #R34463.
g 34251 Minute counter
D 34251 Used by the routines at #R34762, #R35245, #R37841, #R38196, #R38276 and #R38298.
g 34252 Lives remaining
D 34252 Used by the routines at #R34762, #R35211, #R35591 and #R35841.
g 34253 Screen flash counter
D 34253 Initialised to zero by the routine at #R34762, but never used; the code at #R35339 makes the screen flash in Manic Miner fashion if this address holds a non-zero value.
g 34254 Kempston joystick indicator
D 34254 Initialised by the routine at #R34762, and checked by the routines at #R36564 and #R38601. Holds 1 if a joystick is present, 0 otherwise.
g 34255 Willy's pixel y-coordinate
D 34255 Used by the routines at #R34762, #R35245, #R35591, #R36307, #R36564, #R37310, #R38064, #R38098, #R38196, #R38344 and #R38455.
g 34256 Various flags
D 34256 #TABLE(default,centre) {{ =h Bit(s) | =h Meaning | =h Used by }} {{ 0 | Direction Willy is facing (reset=right, set=left) | #R36564, #R38455 }} {{ 1 | Willy's movement flag (set=moving) | #R36564, #R37310 }} {{ 2-7 | Unused (always reset) | }} TABLE#
g 34257 Airborne status indicator
D 34257 Initialised by the routine at #R34762, checked by the routines at #R35591 and #R38344, updated by the routines at #R37046, #R37310 and #R38064, and checked and updated by the routines at #R36307, #R36564 and #R38098. Possible values are:
D 34257 #TABLE(default,centre) {{ =h Value | =h Meaning }} {{ 0 | Willy is neither falling nor jumping }}  {{ 1 | Willy is jumping (see #R36765) }} {{ 2-11 | Willy is falling, and can land safely }} {{ 12-15 | Willy is falling, and has fallen too far to land safely (see #R36574) }} {{ 255 | Willy has collided with a nasty, an arrow, a guardian, or Maria (see #R37046) }} TABLE#
g 34258 Willy's animation frame
D 34258 Used by the routines at #R35245, #R36564, #R37310, #R38344 and #R38455.
g 34259 Address of Willy's location in the attribute buffer at 23552
D 34259 Used by the routines at #R34762, #R36307, #R36564, #R37310, #R38026, #R38046, #R38064, #R38098, #R38196, #R38276, #R38344 and #R38455.
W 34259,2
g 34261 Jumping animation counter
D 34261 Used by the routines at #R36307 and #R36564.
g 34262 Rope status indicator
D 34262 Initialised by the routine at #R35068, checked by the routine at #R36307, and checked and set by the routines at #R36564 and #R37310.
g 34263 Willy's state on entry to the room
D 34263 Initialised by the routine at #R35068, and copied back into #LINK:GameStatusBuffer#34255(34255-34261) by the routine at #R35841.
g 34270 256 minus the number of items remaining
D 34270 Used by the routines at #R34762 and #R37841.
g 34271 Game mode indicator
D 34271 Used by the routines at #R34762, #R35245, #R36564, #R37841, #R38196, #R38276 and #R38298.
D 34271 #TABLE(default,centre) {{ =h Value | =h Meaning }} {{ 0 | Normal }} {{ 1 | All items collected }} {{ 2 | Willy is running to the toilet }} {{ 3 | Willy's head is down the toilet }} TABLE#
g 34272 Inactivity timer
D 34272 Initialised by the routine at #R34762, and updated by the routines at #R35245, #R35591 and #R36564.
g 34273 In-game music note index
D 34273 Initialised by the routine at #R34762, used by the routine at #R35211, and updated by the routine at #R35591.
g 34274 Sound flags
D 34274 #TABLE(default,centre) {{ =h Bit(s) | =h Meaning | =h Used by }} {{ 0 | Keypress flag (set=H-ENTER being pressed, reset=no key pressed) | #R34762, #R35591 }} {{ 1 | In-game music flag (set=music off, reset=music on) | #R35591 }} {{ 2-7 | Unused | }} TABLE#
g 34275 WRITETYPER key counter
D 34275 Used by the routines at #R35245 and #R35591.
g 34276 Temporary variable
D 34276 Used by the routines at #R34499 and #R34620 to hold the entry code, by the routine at #R34762 to hold the index into the message scrolled across the screen after the theme tune has finished playing, and by the routine at #R35914 to hold the distance of the foot from the top of the screen as it descends onto Willy.
b 34277 WRITETYPER
D 34277 Used by the routine at #R35591.
B 34277,b2 (no keys pressed)
B 34279,b2 W
B 34281,b2 R
B 34283,b2 I
B 34285,b2 T
B 34287,b2 E
B 34289,b2 T
B 34291,b2 Y
B 34293,b2 P
B 34295,b2 E
B 34297,b2 R
b 34299 Title screen tune data
D 34299 Used by the routine at #R38562.
B 34299,100,16
b 34399 In-game tune data
D 34399 Used by the routine at #R35591.
B 34399,64,16
c 34463 Give two chances to enter a correct code
D 34463 Used by the routine at #R33792.
  34463,13 Clear the display file and attribute file
  34476 Point #REGix at the message at #R34187 ("Enter Code at grid location#SPACE(5)")
  34480 Display the code entry screen and collect a four-digit code from the user
  34483 Start the game if the code is correct
  34486 Point #REGix at the message at #R34219 ("Sorry, try code at location#SPACE(5)")
  34490 Display the code entry screen and collect another four-digit code from the user
  34493 Start the game if the code is correct
  34496 Otherwise reset the machine
c 34499 Display the code entry screen
D 34499 Used by the routine at #R34463. Displays the code entry screen and waits for a code to be entered. Returns with the zero flag set if the code entered is correct.
R 34499 IX Address of the message to print (#R34187 or #R34219)
  34499,8 Print the message pointed to by #REGix at (8,0)
  34507,11 Print the graphic for the '1' key at (10,2)
  34518,6 Print the graphic for the '2' key at (10,5)
  34524,6 Print the graphic for the '3' key at (10,8)
  34530,6 Print the graphic for the '4' key at (10,11)
  34536,11 Copy the 128 attribute bytes from #R39808 to the screen (lines 8, 9, 10 and 11)
  34547 Collect the LSB of the system variable FRAMES
  34550,5 Add 37 to this value and replace it; this ensures that the value collected on the second pass through this routine is different from the value collected on the first pass
  34555 Is the value between 0 and 178?
  34557 Jump if so
  34559 Otherwise subtract 180; note that if the original value of the LSB of the system variable FRAMES was 142, this leaves #REGa holding 255, which is a #BUG#invalidGridLocation
  34561 Now #REGl holds either 255 or some number between 0 and 178
  34562 Point #REGhl at one of the entries in the table at #R40448 (or at 40703 if #REGl=255)
  34564 Pick up the table entry
  34565 Add #REGl to obtain the actual code
  34566 Store the code at #R34276
  34569 Copy the code index to #REGc; this will be used to compute the grid location
  34570,13 Calculate the ASCII code of the grid location number (0-9) in #REGe
  34583,7 Print the grid location number at (8,30)
  34590,3 Calculate the ASCII code of the grid location letter (A-R) in #REGa
  34593,6 Print the grid location letter at (8,29)
D 34599 Here we enter a loop that prints a 2x2 coloured block at (10,16), (10,19), (10,22) or (10,25) whenever '1', '2', '3' or '4' is pressed, or returns to the calling routine at #R34463 if ENTER is pressed.
  34599 Point #REGix at the attribute file location of the first coloured block at (10,16)
  34603 Print a coloured block when '1', '2', '3' or '4' is pressed, or return to #R34463 if ENTER is pressed
  34606,6 Move #REGix along to the location of the next coloured block
  34612,4 Have we just printed the fourth coloured block at (10,25)?
  34616 If not, jump back to print the next one
  34618 Otherwise rewind #REGix to the location of the first coloured block
c 34620 Read the keyboard during code entry
R 34620 IX Attribute file address of the flashing 2x2 block
D 34620 Used by the routine at #R34499. Waits for '1', '2', '3', '4' or ENTER to be pressed and either prints a coloured block or validates the entered code. Returns to the routine at #R34463 if ENTER is being pressed, with the zero flag reset if the entered code is correct.
  34620,5 Read keys 1-2-3-4-5
  34625,4 Is '1', '2', '3' or '4' (still) being pressed?
  34629 Jump back if so
  34631,4 Read keys H-J-K-L-ENTER
  34635 Is ENTER being pressed?
  34637,2 Jump if not
  34639 Pick up the attribute byte of the fourth 2x2 block at (10,25)
  34642,4 Has the fourth digit been entered yet?
  34646 Jump if not
D 34648 We have four coloured blocks, and ENTER is being pressed. Time to validate the entered code.
  34648,8 Compute bits 0 and 1 of the entered code from the attribute byte of the fourth coloured block at (10,25) and store them in #REGc
  34656,10 Compute bits 4 and 5 of the entered code from the attribute byte of the second coloured block at (10,19) and store them in #REGc (alongside bits 0 and 1)
  34666,10 Compute bits 2 and 3 of the entered code from the attribute byte of the third coloured block at (10,22) and store them in #REGc (alongside bits 0, 1, 4 and 5)
  34676,10 Compute bits 6 and 7 of the entered code from the attribute byte of the first coloured block at (10,16) in #REGa
  34686 Drop the return address from the stack
  34687 Merge bits 0-5 of the entered code into #REGa; now #REGa holds all 8 bits of the entered code
  34688 Point #REGhl at #R34276 (where the correct entry code is stored)
  34691 Set the zero flag if the entered code matches
  34692 Return to the routine at #R34463
D 34693 Here we check whether '1', '2', '3' or '4' is being pressed.
  34693,16 Make sure the current 2x2 block is flashing
  34709,5 Read keys 1-2-3-4-5
  34714,2 Keep only bits 0-3 (keys 1-2-3-4)
  34716 #REGe=8 (INK 0: PAPER 1)
  34718 Is '1' alone being pressed?
  34720 Jump if so
  34722 #REGe=16 (INK 0: PAPER 2)
  34724 Is '2' alone being pressed?
  34726 Jump if so
  34728 #REGe=24 (INK 0: PAPER 3)
  34730 Is '3' alone being pressed?
  34732 Jump if so
  34734 #REGe=32 (INK 0: PAPER 4)
  34736 Is '4' alone being pressed?
  34738,3 If not, jump back to check the ENTER key
D 34741 Exactly one of the number keys '1', '2', '3' or '4' is being pressed. #REGe holds the corresponding attribute byte to use for the coloured block.
  34741,12 Set the colour of the 2x2 block (no longer flashing)
  34753,8 Pause for about 0.02s
c 34762 Display the title screen and play the theme tune
D 34762 Used by the routines at #R34463, #R35245 and #R35914.
D 34762 The first thing this routine does is initialise some game status buffer variables in preparation for the next game.
  34762 #REGa=0
  34763 Initialise the Kempston joystick indicator at #R34254
  34766 Initialise the in-game music note index at #R34273
  34769 Initialise the (unused) screen flash counter at #R34253
  34772 Initialise the airborne status indicator at #R34257
  34775 Initialise the minute counter at #R34251
  34778 Initialise the inactivity timer at #R34272
  34781 Initialise the game mode indicator at #R34271
  34784,5 Initialise the number of lives remaining at #R34252
  34789,5 Initialise Willy's pixel y-coordinate at #R34255
  34794,5 Initialise the current room number at #R33824 to 33 (#R57600(The Bathroom))
  34799,6 Initialise Willy's coordinates at #R34259 to (13,20)
  34805,11 Initialise the number of items collected at #R34172 to "000"
  34816 Page #R41984(164) holds the first byte of each entry in the item table
  34818 Pick up the index of the first item from #R41983
  34821 Point #REGhl at the entry for the first item
  34822 Initialise the counter of items remaining at #R34270
  34825,5 Set the collection flag for every item in the item table at #R41984
  34830,5 Initialise the keypress flag in bit 0 at #R34274
D 34835 Next, prepare the screen.
  34835,13 Clear the entire display file
  34848,8 Copy the attribute bytes for the top two-thirds of the title screen from #R38912 to the attribute file
  34856,13 Copy the attribute value 70 (INK 6: PAPER 0: BRIGHT 1) into the row of 32 cells from (19,0) to (19,31) on the screen
  34869,12 Print "+++++ Press ENTER to Start +++++" (see #R33876) at (19,0)
  34881 Point #REGde at the first byte of the attribute file
D 34884 The following loop scans the top two-thirds of the attribute file, which contains values 0, 4, 5, 8, 9, 36, 37, 40, 41, 44, 45 and 211 (copied from #R38912). Whenever a value other than 0, 9, 36, 45 or 211 is found, a triangle UDG is drawn at the corresponding location in the display file.
  34884 Pick up a byte from the attribute file
  34885 Is it 0 (INK 0: PAPER 0)?
  34886 If so, jump to consider the next byte in the attribute file
  34888 Is it 211 (INK 3: PAPER 2: BRIGHT 1: FLASH 1)?
  34890 If so, jump to consider the next byte in the attribute file
  34892 Is it 9 (INK 1: PAPER 1)?
  34894 If so, jump to consider the next byte in the attribute file
  34896 Is it 45 (INK 5: PAPER 5)?
  34898 If so, jump to consider the next byte in the attribute file
  34900 Is it 36 (INK 4: PAPER 4)?
  34902 If so, jump to consider the next byte in the attribute file
  34904 #REGc=0; this will be used as an offset from the triangle UDG base address (#R33841)
  34906 Is the attribute value 8 (INK 0: PAPER 1)?
  34908 Jump if so
  34910 Is it 41 (INK 1: PAPER 5)?
  34912 Jump if so
  34914 Is it 44 (INK 4: PAPER 5)?
  34916 Jump if so
  34918 Is it 5 (INK 5: PAPER 0)?
  34920 Jump if so
  34922,2 Set the triangle UDG offset to 16
  34926,3 Change the attribute byte here from 44 (INK 4: PAPER 5) to 37 (INK 5: PAPER 4)
  34929,14 Point #REGhl at the triangle UDG to draw (#R33841, #R33849, #R33857 or #R33865)
  34943 Save the attribute file address briefly
  34944 Set the zero flag if we're still in the top third of the attribute file
  34946 Point #REGde at the top third of the display file
  34948 Jump if we're still in the top third of the attribute file
  34950 Point #REGde at the middle third of the display file
  34952 There are eight pixel rows in a triangle UDG
  34954 Draw a triangle UDG on the screen
  34957 Restore the attribute file address to #REGde
  34958 Point #REGde at the next byte in the attribute file
  34959,3 Have we finished scanning the top two-thirds of the attribute file yet?
  34962 If not, jump back to examine the next byte
D 34965 Now check whether there is a joystick connected.
  34965 #REGb=0, #REGc=31 (joystick port)
  34968 Disable interrupts (which are already disabled)
  34969 #REGa=0
  34970,5 Combine 256 readings of the joystick port in #REGa
  34975 Is a joystick connected (bit 5 reset)?
  34977 Jump if not
  34979,5 Set the Kempston joystick indicator at #R34254 to 1
D 34984 And finally, play the theme tune and check for keypresses.
  34984 Point #REGhl at the theme tune data at #R34299
  34987 Play the theme tune
  34990 Start the game if ENTER, 0 or the fire button was pressed
  34993,4 Initialise the temporary game status buffer variable at #R34276 to 0; this will be used as an index for the message scrolled across the screen (see #R33876)
  34997,3 Cycle the INK and PAPER colours
  35000,13 Copy the attribute value 79 (INK 7: PAPER 1: BRIGHT 1) into the row of 32 cells from (19,0) to (19,31) on the screen
  35013 Pick up the message index from #R34276
  35016,9 Point #REGix at the corresponding location in the message at #R33876
  35025,8 Print 32 characters of the message at (19,0)
  35033,7 Prepare a value between 50 and 81 in #REGa (for the routine at #R38622)
  35040 Make a sound effect
  35043,5 Read keys H-J-K-L-ENTER and 6-7-8-9-0
  35048 Keep only bit 0 of the result (ENTER, 0)
  35050 Was ENTER or 0 pressed?
  35052 Jump if so to start the game
  35054 Pick up the message index from #R34276
  35057 Increment it
  35058 Set the zero flag if we've reached the end of the message
  35060 Store the new message index at #R34276
  35063 Jump back unless we've finished scrolling the message across the screen
  35065 Jump back to prepare the screen and play the theme tune again
c 35068 Start the game
  35068,11 Initialise the time by copying the text at #R34181 (" 7:00a") to #R34175
  35079,11 Copy the attribute bytes from #R39424 to the bottom third of the screen
D 35090 This entry point is used by the routines at #R35591 (to teleport into a room), #R35841 (to reinitialise the room after Willy has lost a life), #R38026 (when Willy has entered the room from the right), #R38046 (when Willy has entered the room from the left), #R38064 (when Willy has entered the room from below) and #R38098 (when Willy has entered the room from above).
  35090 Pick up the current room number from #R33824
  35093,5 Point #REGhl at the first byte of the room definition
  35098,8 Copy the room definition into the buffer at #R32768
  35106 Point #REGix at the first byte of the first entity specification for the current room at #R33008
  35110 Point #REGde at the first byte of the entity buffer at #R33024
  35113 There are at most eight entities in a room
  35115 Pick up the first byte of the entity specification
  35118,7 Point #REGhl at the corresponding entry in the table of entity definitions at #R40960
  35125,5 Copy the first two bytes of the entity definition into the entity buffer
  35130,4 Copy the second byte of the entity specification into the third byte of the entity definition
  35134,5 Copy the remaining six bytes of the entity definition into the entity buffer
  35139,4 Point #REGix at the first byte of the next entity specification
  35143 Have we copied all eight entity definitions into the entity buffer yet?
  35144 If not, jump back to copy the next one
  35146,11 Copy the seven bytes that define Willy's state (position, animation frame etc.) on entry to this room from #LINK:GameStatusBuffer#34255(34255-34261) to #R34263
  35160,13 Clear the bottom third of the display file
  35157,3 Draw the current room to the screen buffer at 28672 and the attribute buffer at 24064
  35173,12 Print the room name at (16,0)
  35185,12 Print "Items collected 000 Time 00:00 m" (see #R34132) at (19,0)
  35197 Pick up the border colour for the current room from #R32990
  35200,4 Set the border colour
  35204,4 Initialise the rope status indicator at #R34262 to 0
  35208 Enter the main loop
c 35211 Draw the remaining lives
  35211 Pick up the number of lives remaining from #R34252
  35214 Set #REGhl to the display file address at which to draw the first Willy sprite
  35217 Are there any lives remaining?
  35218 Return if not
  35219 Initialise #REGb to the number of lives remaining
D 35220 The sprite-drawing loop begins.
  35220 #REGc=0; this tells the sprite-drawing routine at #R37974 to overwrite any existing graphics
  35222,2 Save #REGhl and #REGbc briefly
  35224 Pick up the in-game music note index from #R34273; this will determine the animation frame for the Willy sprites
  35227,5 Now #REGa=0 (frame 0), 32 (frame 1), 64 (frame 2) or 96 (frame 3)
  35232,3 Point #REGde at the corresponding Willy sprite (at #R40192, #R40224, #R40256 or #R40288)
  35235 Draw the Willy sprite on the screen
  35238,2 Restore #REGhl and #REGbc
  35240,2 Move #REGhl along to the location at which to draw the next Willy sprite
  35242,2 Jump back to draw any remaining sprites
c 35245 Main loop (1)
  35245 Draw the remaining lives
  35248,11 Copy the contents of the attribute buffer at 24064 (the attributes for the empty room) into the attribute buffer at 23552
  35259,11 Copy the contents of the screen buffer at 28672 (the tiles for the empty room) into the screen buffer at 24576
  35270 Move the rope and guardians in the current room
  35273 Pick up the game mode indicator from #R34271
  35276 Is Willy's head down the toilet?
  35278 If not, move Willy
  35281 Pick up Willy's pixel y-coordinate from #R34255
  35284 Is it 225 or greater?
  35286 If so, move Willy into the room above
  35289 Pick up the game mode indicator from #R34271
  35292 Is Willy's head down the toilet?
  35294 If not, check and set the attribute bytes for Willy's sprite in the buffer at 23552
  35297 Pick up the game mode indicator from #R34271
  35300 Is Willy on his way to the toilet?
  35302 If so, check whether he's reached it yet
  35305 Deal with special rooms (#R58112(Master Bedroom), #R57600(The Bathroom))
  35308 Draw the rope, arrows and guardians in the current room
  35311 Move the conveyor in the current room (if there is one)
  35314,3 Draw the items in the current room (if there are any) and collect any that Willy is touching
  35317,11 Copy the contents of the screen buffer at 24576 to the display file
  35328 Pick up the game mode indicator from #R34271
  35331,3 Now #REGa=1 if Willy is running to the toilet or already has his head down it, 0 otherwise
  35334,5 Set Willy's animation frame at #R34258 to 2 or 3 if Willy is running to the toilet or already has his head down it
  35339 Pick up the screen flash counter (unused and always 0) from #R34253
  35342 Is it zero?
  35343 Jump if so (this jump is always made)
D 35345 The next section of code is never executed.
  35345,4 Decrement the screen flash counter at #R34253
  35349,5 Move bits 0-2 into bits 3-5 and clear all the other bits
  35354,12 Set every attribute byte in the buffer at 23552 to this value
D 35366 Normal service resumes here.
  35366,11 Copy the contents of the attribute buffer at 23552 to the attribute file
  35377,12 Print the current time (see #R34175) at (19,25)
  35389,12 Print the number of items collected (see #R34172) at (19,16)
  35401,7 Increment the minute counter at #R34251
  35408 Jump unless the minute counter has ticked over to 0
D 35410 A minute of game time has passed. Update the game clock accordingly.
  35410 Point #REGix at the current time at #R34175
  35414 Increment the units digit of the minute
  35417 Pick up the new units digit
  35420 Was it '9' before?
  35422 Jump if not
  35424 Set the units digit of the minute to '0'
  35428 Increment the tens digit of the minute
  35431 Pick up the new tens digit
  35434 Was it '5' before?
  35436 Jump if not
  35438 Set the tens digit of the minute to '0'
  35442 Pick up the tens digit of the hour
  35445 Is it currently '1'?
  35447 Jump if not
  35449 Increment the units digit of the hour
  35452 Pick up the new units digit
  35455 Was it '2' before?
  35457 Jump if not
  35459 Pick up the 'a' or 'p' of 'am' or 'pm'
  35462 Is it 'p'?
  35464 If so, quit the game (it's midnight)
  35467 Set the tens digit of the hour to ' ' (space)
  35471 Set the units digit of the hour to '1'
  35475,4 Set the 'a' or 'p' of 'am' or 'pm' to 'p'
  35481 Increment the units digit of the hour
  35484 Pick up the new units digit
  35487 Was it '9' before?
  35489 Jump if not
  35491 Set the units digit of the hour to '0'
  35495 Set the units digit of the hour to '1'
D 35499 Now check whether any non-movement keys are being pressed.
  35499,5 Read keys SHIFT-Z-X-C-V
  35504 Save the result in #REGe
  35505,4 Read keys B-N-M-SS-SPACE
  35509 Combine the results
  35510 Are SHIFT and SPACE being pressed?
  35512 If so, quit the game
  35515,7 Increment the inactivity timer at #R34272
  35522 Jump if the inactivity timer is now 0 (no keys have been pressed for a while)
  35524,4 Read keys A-S-D-F-G
  35528,4 Are any of these keys being pressed?
  35532 Jump if not
  35534 Prepare the delay counters in #REGd and #REGe for the pause loop that follows
D 35537 The following loop pauses the game until any key except A, S, D, F or G is pressed.
  35537,4 Read every half-row of keys except A-S-D-F-G
  35541,4 Are any of these keys being pressed?
  35545 If so, resume the game
  35547 Increment the delay counter in #REGe
  35548 Jump back unless it's zero
  35550 Increment the delay counter in #REGd
  35551 Jump back unless it's zero
  35553 Pick up the WRITETYPER key counter from #R34275
  35556 Has WRITETYPER been keyed in yet?
  35558 If not, cycle the INK and PAPER colours
  35561 Jump back to the beginning of the pause loop
c 35563 Cycle the INK and PAPER colours
D 35563 Used by the routines at #R34762 (while scrolling the instructions across the screen) and #R35245 (while the game is paused).
  35563 Point #REGhl at the first byte of the attribute file
  35566 Pick up this byte
  35567 Keep only bits 0-2 (the INK colour)
  35569 Set the border colour to match
D 35571 Now we loop over every byte in the attribute file.
  35571 Pick up an attribute file byte
  35572,4 Cycle the INK colour forward by three
  35576 Save the new INK colour in #REGd
  35577 Pick up the attribute file byte again
  35578,4 Cycle the PAPER colour forward by three (and turn off any BRIGHT colours)
  35582 Merge in the new INK colour
  35583 Save the new attribute byte
  35584 Point #REGhl at the next byte in the attribute file
  35585,3 Have we reached the end of the attribute file yet?
  35588,2 If not, jump back to modify the next byte
c 35591 Main loop (2)
D 35591 Used by the routine at #R35245. The main entry point is used when resuming the game after it has been paused.
  35591,11 Copy the attribute bytes from #R39424 to the bottom third of the screen
  35602 Pick up the border colour for the current room from #R32990
  35605 Restore the border colour
  35607 Pick up the airborne status indicator from #R34257
  35610 Has Willy collided with a nasty, an arrow, a guardian, or Maria?
  35612 If so, lose a life
D 35615 Now read the keys H, J, K, L and ENTER (which toggle the in-game music).
  35615 Prepare #REGb for reading keys H-J-K-L-ENTER
  35617 Point #REGhl at the sound flags at #R34274
  35620 Read keys H-J-K-L-ENTER
  35622,4 Are any of these keys being pressed?
  35626,2 Jump if not
  35628 Were any of these keys being pressed the last time we checked?
  35630 Jump if so
  35632,4 Set bit 0 (the keypress flag) and flip bit 1 (the in-game music flag) at #R34274
  35638 Reset bit 0 (the keypress flag) at #R34274
  35640 Has the in-game music been switched off?
  35642 Jump if so
D 35644 The next section of code plays a note of the in-game music.
  35644,4 Reset the inactivity timer at #R34272 (the game does not automatically pause after a period of inactivity if the in-game music is playing)
  35648,7 Increment the in-game music note index at #R34273
  35655,10 Point #REGhl at the appropriate entry in the tune data table at #R34399
  35665 Pick up the number of lives remaining (0-7) from #R34252
  35668,6 #REGa=28-4#REGa; this value adjusts the pitch of the note that is played depending on how many lives are remaining (the more lives remaining, the higher the pitch)
  35674 Add the entry from the tune data table for the current note
  35675 Copy this value to #REGd (which determines the pitch of the note)
  35676 Pick up the border colour for the current room from #R32990
  35679 Initialise the pitch delay counter in #REGe
  35680 Initialise the duration delay counters in #REGb (0) and #REGc (3)
  35683,13 Produce a note of the in-game music
D 35696 Here we check the teleport keys.
  35696,5 Read keys 6-7-8-9-0
  35701 Is '9' (the activator key) being pressed?
  35703 Jump if not
  35706,5 Keep only bit 4 (corresponding to the '6' key), flip it, and move it into bit 5
  35711 Now bit 5 of #REGd is set if '6' is being pressed
  35712 Pick up the WRITETYPER key counter from #R34275
  35715 Has WRITETYPER been keyed in yet?
  35717 Jump if not
  35720,5 Read keys 1-2-3-4-5
  35725,3 Keep only bits 0-4 and flip them
  35728 Copy bit 5 of #REGd into #REGa; now #REGa holds the number of the room to teleport to
  35729 Store the room number at #R33824
  35732,3 Teleport into the room
D 35735 Finally, check the WRITETYPER keys.
  35735 Pick up the WRITETYPER key counter from #R34275
  35738 Has WRITETYPER been keyed in yet?
  35740 If so, jump back to the start of the main loop
  35743 Pick up the current room number from #R33824
  35746 Are we in #R56320(First Landing)?
  35748 If not, jump back to the start of the main loop
  35751 Pick up Willy's pixel y-coordinate from #R34255
  35754 Is Willy on the floor at the bottom of the staircase?
  35756 If not, jump back to the start of the main loop
  35759 Pick up the WRITETYPER key counter (0-9) from #R34275
  35762,10 Point #REGix at the corresponding entry in the WRITETYPER table at #R34279
  35772,5 Read keys Q-W-E-R-T
  35777 Keep only bits 0-5
  35779 Does this match the first byte of the entry in the WRITETYPER table?
  35782 Jump if so
  35784 Are any of the keys Q-W-E-R-T being pressed?
  35786 If not, jump back to the start of the main loop
  35789 Does the keyboard reading match the first byte of the previous entry in the WRITETYPER table?
  35792 If so, jump back to the start of the main loop
  35795,4 Reset the WRITETYPER key counter at #R34275 to 0 (an incorrect key was pressed)
  35799 Jump back to the start of the main loop
  35802,4 Read keys Y-U-I-O-P
  35806 Keep only bits 0-5
  35808 Does this match the second byte of the entry in the WRITETYPER table?
  35811 If so, jump to increment the WRITETYPER key counter
  35813 Are any of the keys Y-U-I-O-P being pressed?
  35815 If not, jump back to the start of the main loop
  35818 Does the keyboard reading match the second byte of the previous entry in the WRITETYPER table?
  35821 If so, jump back to the start of the main loop
  35824,4 Reset the WRITETYPER key counter at #R34275 to 0 (an incorrect key was pressed)
  35828 Jump back to the start of the main loop
  35831,7 Increment the WRITETYPER key counter at #R34275
  35838 Jump back to the start of the main loop
c 35841 Lose a life
  35841 #REGa=71 (INK 7: PAPER 0: BRIGHT 1)
D 35843 The following loop fills the top two thirds of the attribute file with a single value (71 TO 64 STEP -1) and makes a sound effect.
  35843,12 Fill the top two thirds of the attribute file with the value in #REGa
  35855 Save the attribute byte (64-71) in #REGe for later retrieval
  35856,9 #REGd=7+8*(7-(#REGe AND 7)); this value determines the pitch of the short note that will be played
  35865,7 #REGc=8+32*(#REGe AND 7); this value determines the duration of the short note that will be played
  35872 Set bit 4 of #REGa (for no apparent reason)
  35874 Set #REGa=0 (this will make the border black)
  35875,10 Produce a short note whose pitch is determined by #REGd and whose duration is determined by #REGc
  35885 Restore the attribute byte (originally 71) to #REGa
  35886 Decrement it (effectively decrementing the INK colour)
  35887 Have we used attribute value 64 (INK 0) yet?
  35889 If not, jump back to update the INK colour in the top two thirds of the screen and make another sound effect
D 35891 Now check whether any lives remain.
  35891,4 Pick up the number of lives remaining from #R34252
  35895 Are there any lives remaining?
  35896 If not, display the game over sequence
  35899 Decrease the number of lives remaining by one
  35900,11 Restore Willy's state upon entry to the room by copying the seven bytes at #R34263 back into #LINK:GameStatusBuffer#34255(34255-34261)
  35911 Reinitialise the room and resume the game
c 35914 Display the game over sequence
  35914,13 Clear the top two-thirds of the display file
  35927,4 Initialise the temporary game status buffer variable at #R34276; this variable will determine the distance of the foot from the top of the screen
  35931,11 Draw Willy at (12,15)
  35942,11 Draw the barrel underneath Willy at (14,15)
D 35953 The following loop draws the foot's descent onto the barrel that supports Willy.
  35953 Pick up the distance variable from #R34276
  35956,3 Point #REGbc at the corresponding entry in the screen buffer address lookup table at #R33280
  35959,9 Point #REGhl at the corresponding location in the display file
  35968,8 Draw the foot at this location, without erasing the foot at the previous location; this leaves the portion of the foot sprite that's above the ankle in place, and makes the foot appear as if it's at the end of a long, extending leg
  35976 Pick up the distance variable from #R34276
  35979 #REGa=255-#REGa
  35980 Store this value (63-255) in #REGe; it determines the (rising) pitch of the sound effect that will be made
  35981 #REGa=0 (black border)
  35982 #REGc=64; this value determines the duration of the sound effect
  35985,10 Produce a short note whose pitch is determined by #REGe
  35995,9 Prepare #REGbc, #REGde and #REGhl for setting the attribute bytes in the top two-thirds of the screen
  36004 Pick up the distance variable from #R34276
  36007 Keep only bits 2 and 3
  36009 Shift bits 2 and 3 into bits 3 and 4; these bits determine the PAPER colour: 0, 1, 2 or 3
  36010 Set bits 0-2 (INK 7) and 6 (BRIGHT 1)
  36012,3 Copy this attribute value into the top two-thirds of the screen
  36015 Reset bits 0 and 2, and retain all other bits
  36017 Set bit 1 (INK 2)
  36019,12 Copy this attribute value to the cells at (14,15), (14,16), (15, 15) and (15, 16) (where the barrel is, so that it remains red)
  36031,8 Add 4 to the distance variable at #R34276; this will move the foot sprite down two pixel rows
  36039 Has the foot met the barrel yet?
  36041 Jump back if not
D 36043 Now print the "Game Over" message, just to drive the point home.
  36043,12 Print "Game" (see #R34164) at (6,10)
  36055,12 Print "Over" (see #R34168) at (6,18)
  36067,5 Prepare the delay counters for the following loop; the counter in #REGc will also determine the INK colours to use for the "Game Over" message
D 36072 The following loop makes the "Game Over" message glisten for about 1.57s.
  36072 Delay for about a millisecond
  36074,8 Change the INK colour of the "G" in "Game" at (6,10)
  36082,8 Change the INK colour of the "a" in "Game" at (6,11)
  36090,8 Change the INK colour of the "m" in "Game" at (6,12)
  36098,8 Change the INK colour of the "e" in "Game" at (6,13)
  36106,8 Change the INK colour of the "O" in "Over" at (6,18)
  36114,8 Change the INK colour of the "v" in "Over" at (6,19)
  36122,8 Change the INK colour of the "e" in "Over" at (6,20)
  36130,8 Change the INK colour of the "r" in "Over" at (6,21)
  36138 Decrement the counter in #REGc
  36139 Jump back unless it's zero
  36141 Decrement the counter in #REGd (initially 6)
  36142 Jump back unless it's zero
  36144 Display the title screen and play the theme tune
c 36147 Draw the current room to the screen buffer at 28672
  36147 Fill the buffer at 24064 with attribute bytes for the current room
  36150 Point #REGix at the first byte of the attribute buffer at 24064
  36154,5 Set the operand of the 'LD D,n' instruction at 36188 (below) to 112
  36159 Draw the tiles for the top half of the room to the screen buffer at 28672
  36162 Point #REGix at the 256th byte of the attribute buffer at 24064 in preparation for drawing the bottom half of the room; this instruction is redundant, since #REGix already holds 24320
  36166,5 Set the operand of the 'LD D,n' instruction at 36188 (below) to 120
  36171 #REGc will count 256 tiles
D 36173 The following loop draws 256 tiles (for either the top half or the bottom half of the room) to the screen buffer at 28672.
  36173 #REGe holds the LSB of the screen buffer address
  36174 Pick up an attribute byte from the buffer at 24064; this identifies the type of tile (background, floor, wall, nasty, ramp or conveyor) to be drawn
  36177 Point #REGhl at the attribute byte of the background tile at #R32928
  36180,5 Move #REGhl through the attribute bytes and graphic data of the background, floor, wall, nasty, ramp and conveyor tiles until we find a byte that matches the attribute byte of the tile to be drawn
  36185 Restore the value of the tile counter in #REGc
  36186 There are eight bytes in the tile
  36188 This instruction is set to either 'LD D,112' or 'LD D,120' above; now #REGde holds the appropriate address in the screen buffer at 28672
  36190,6 Copy the tile graphic data to the screen buffer at 28762
  36196 Move #REGix along to the next byte in the attribute buffer
  36198 Have we drawn 256 tiles yet?
  36199,3 If not, jump back to draw the next one
c 36203 Fill the buffer at 24064 with attribute bytes for the current room
D 36203 Used by the routine at #R36147. Fills the buffer at 24064 with attribute bytes for the background, floor, wall, nasty, conveyor and ramp tiles in the current room.
  36203 Point #REGhl at the first room layout byte in the room buffer at #R32768
  36206 Point #REGix at the first byte of the attribute buffer at 24064
D 36210 The following loop copies the attribute bytes for the background, floor, wall and nasty tiles into the buffer at 24064.
  36210 Pick up a room layout byte
  36211,2 Move bits 6 and 7 into bits 0 and 1
  36213 Copy the attribute byte for this tile into the buffer at 24064
  36216 Pick up the room layout byte again
  36217,4 Move bits 4 and 5 into bits 0 and 1
  36221 Copy the attribute byte for this tile into the buffer at 24064
  36224 Pick up the room layout byte again
  36225,2 Move bits 2 and 3 into bits 0 and 1
  36227 Copy the attribute byte for this tile into the buffer at 24064
  36230 Pick up the room layout byte again; this time the required bit-pair is already in bits 0 and 1
  36231 Copy the attribute byte for this tile into the buffer at 24064
  36234 Point #REGhl at the next room layout byte
  36235,3 Have we processed all 128 room layout bytes yet?
  36238 If not, jump back to process the next one
D 36240 Next consider the conveyor tiles (if any).
  36240 Pick up the length of the conveyor
  36243 Is there a conveyor in the room?
  36244 Jump if not
  36246 Pick up the coordinates of the left end of the conveyor
  36249 #REGb will count the conveyor tiles
  36250 Pick up the attribute byte for the conveyor tile from #R32973
  36253,4 Copy the attribute bytes for the conveyor tiles into the buffer at 24064
D 36257 And finally consider the ramp tiles (if any).
  36257 Pick up the length of the ramp
  36260 Is there a ramp in the room?
  36261 Return if not
  36262 Pick up the coordinates of the bottom of the ramp
  36265,5 Pick up the direction byte of the ramp definition; #REGa=0 (ramp goes up to the left) or 1 (ramp goes up to the right)
  36270,6 Now #REGde=-33 (ramp goes up to the left) or -31 (ramp goes up to the right)
  36276 Pick up the length of the ramp
  36279 #REGb will count the ramp tiles
  36280 Pick up the attribute byte for the ramp tile from #R32964
  36283,4 Copy the attribute bytes for the ramp tiles into the buffer at 24064
c 36288 Copy a room attribute byte into the buffer at 24064
D 36288 Used by the routine at #R36203. On entry, #REGa holds a room layout byte, rotated such that the bit-pair corresponding to the tile of interest is in bits 0 and 1.
R 36288 A Room layout byte (rotated)
R 36288 IX Attribute buffer address (24064-24575)
  36288 Keep only bits 0 and 1; #REGa=0 (background), 1 (floor), 2 (wall) or 3 (nasty)
  36290,7 Multiply by 9 and add 160; now #REGa=160 (background), 169 (floor), 178 (wall) or 187 (nasty)
  36297,3 Point #REGde at the attribute byte for the background, floor, wall or nasty tile in the room buffer at #R32768
  36300,4 Copy the attribute byte into the buffer at 24064
  36304,2 Move #REGix along to the next byte in the attribute buffer
c 36307 Move Willy (1)
D 36307 Used by the routine at #R35245. This routine deals with Willy if he's jumping or falling.
  36307 Pick up the rope status indicator from #R34262
  36310,3 Is Willy on a rope?
  36313 Jump if so
  36316 Pick up the airborne status indicator from #R34257
  36319 Is Willy jumping?
  36321 Jump if not
D 36323 Willy is currently jumping.
  36323 Pick up the jumping animation counter (0-18) from #R34261
  36326 Discard bit 0
  36328 Now -8<=#REGa<=10 (and #REGa is even)
  36330,5 Adjust Willy's pixel y-coordinate at #R34255 depending on where Willy is in the jump
  36335 Is the new value negative (above the top of the screen)?
  36337 If so, move Willy into the room above
  36340 Adjust Willy's attribute buffer location at #R34259 depending on his pixel y-coordinate
  36343 Pick up the attribute byte of the wall tile for the current room from #R32946
  36346 Is the top-left cell of Willy's sprite overlapping a wall tile?
  36347 Jump if so
  36350 Point #REGhl at the top-right cell occupied by Willy's sprite
  36351 Is the top-right cell of Willy's sprite overlapping a wall tile?
  36352 Jump if so
  36355,7 Increment the jumping animation counter at #R34261
  36362 #REGa=J-8, where J (1-18) is the new value of the jumping animation counter
  36364 Jump if J>=8
  36367 #REGa=8-J (1<=J<=7, 1<=#REGa<=7)
  36369 #REGa=1+ABS(J-8)
  36370,4 #REGd=8*(1+ABS(J-8)); this value determines the pitch of the jumping sound effect (rising as Willy rises, falling as Willy falls)
  36374 #REGc=32; this value determines the duration of the jumping sound effect
  36376,3 Pick up the border colour for the current room from #R32990
  36379,10 Make a jumping sound effect
  36389 Pick up the jumping animation counter (1-18) from #R34261
  36392 Has Willy reached the end of the jump?
  36394 Jump if so
  36397 Is the jumping animation counter now 16?
  36399 Jump if so
  36401 Is the jumping animation counter now 13?
  36403 Jump if not
D 36406 If we get here, then Willy is standing on the floor, or he's falling, or his jumping animation counter is 13 or 16.
  36406,3 Pick up Willy's pixel y-coordinate from #R34255
  36409 Does Willy's sprite occupy six cells at the moment?
  36411 Jump if so
  36413 Pick up Willy's attribute buffer coordinates from #R34259
  36416,4 Point #REGhl at the left-hand cell below Willy's sprite
  36420 Is this location below the floor of the current room?
  36422,3 If so, move Willy into the room below
  36425 Pick up the attribute byte of the nasty tile for the current room from #R32955
  36428 Does the left-hand cell below Willy's sprite contain a nasty?
  36429 Jump if so
  36431 Point #REGhl at the right-hand cell below Willy's sprite
  36432 Pick up the attribute byte of the nasty tile for the current room from #R32955 (again, redundantly)
  36435 Does the right-hand cell below Willy's sprite contain a nasty?
  36436 Jump if so
  36438 Pick up the attribute byte of the background tile for the current room from #R32928
  36441 Set the zero flag if the right-hand cell below Willy's sprite is empty
  36442 Point #REGhl at the left-hand cell below Willy's sprite
  36443 Jump if the right-hand cell below Willy's sprite is not empty
  36446 Is the left-hand cell below Willy's sprite empty?
  36447 Jump if not
  36450 Pick up the airborne status indicator from #R34257
  36453 Is Willy jumping?
  36455 Jump if so
D 36458 If we get here, then Willy is either in the process of falling or just about to start falling.
  36458,5 Reset bit 1 at #R34256
  36463 Pick up the airborne status indicator from #R34257
  36466 Is Willy already falling?
  36467 Jump if not
  36470 Increment the airborne status indicator
  36471 Is it 16 now?
  36473 Jump if not
  36475 Decrease the airborne status indicator from 16 to 12
  36477 Update the airborne status indicator at #R34257
  36480,5 #REGd=8*#REGa; this value determines the pitch of the falling sound effect
  36485 #REGc=32; this value determines the duration of the falling sound effect
  36487,3 Pick up the border colour for the current room from #R32990
  36490,10 Make a falling sound effect
  36500,8 Add 8 to Willy's pixel y-coordinate at #R34255; this moves Willy downwards by 4 pixels
D 36508 This entry point is used by the routine at #R37310 to update Willy's attribute buffer location when he's on a rope.
  36508,3 #REGl=16*Y, where Y is Willy's screen y-coordinate (0-14)
  36511 Clear #REGa and the carry flag
  36512 Now #REGl=32*(Y-8*INT(Y/8)), and the carry flag is set if Willy is in the lower half of the room (Y>=8)
  36514,3 #REGh=92 or 93 (MSB of the address of Willy's location in the attribute buffer)
  36517,5 Pick up Willy's screen x-coordinate (0-30) from bits 0-5 at #R34259
  36522,2 Now #REGl holds the LSB of Willy's attribute buffer address
  36524,3 Store Willy's updated attribute buffer location at #R34259
D 36528 Willy has just finished a jump.
  36528,5 Set the airborne status indicator at #R34257 to 6: Willy will continue to fall unless he's landed on a wall or floor block
D 36534 Willy has just started falling.
  36534,5 Set the airborne status indicator at #R34257 to 2
D 36540 The top-left or top-right cell of Willy's sprite is overlapping a wall tile.
  36540,10 Adjust Willy's pixel y-coordinate at #R34255 so that the top row of cells of his sprite are just below the wall tile
  36550 Adjust Willy's attribute buffer location at #R34259 to account for this new pixel y-coordinate
  36553,5 Set the airborne status indicator at #R34257 to 2: Willy has started falling
  36558,5 Reset bit 1 at #R34256
c 36564 Move Willy (2)
R 36564 HL Attribute buffer address of the left-hand cell below Willy's sprite (if Willy is not on a rope)
  36564 Initialise #REGe to 255 (all bits set); it will be used to hold keyboard and joystick readings
  36566 Pick up the rope status indicator from #R34262
  36569,3 Is Willy on a rope?
  36572 Jump if so
  36574 Pick up the airborne status indicator from #R34257
  36577 Has Willy just landed after falling from too great a height?
  36579,3 If so, kill him
  36582,4 Reset the airborne status indicator at #R34257 (Willy has landed safely)
  36586 Pick up the attribute byte of the conveyor tile for the current room from #R32973
  36589 Does the left-hand cell below Willy's sprite contain a conveyor tile?
  36590 Jump if so
  36592 Point #REGhl at the right-hand cell below Willy's sprite
  36593 Does the right-hand cell below Willy's sprite contain a conveyor tile?
  36594 Jump if not
  36596 Pick up the direction byte of the conveyor definition from #R32982 (0=left, 1=right)
  36599,3 Now #REGe=253 (bit 1 reset) if the conveyor is moving left, or 254 (bit 0 reset) if it's moving right
  36602,5 Read keys P-O-U-I-Y (right, left, right, left, right) into bits 0-4 of #REGa
  36607,4 Set bit 5 and reset bits 6 and 7
  36611 Reset bit 0 if the conveyor is moving right, or bit 1 if it's moving left
  36612 Save the result in #REGe
  36613 Pick up the game mode indicator (0, 1 or 2) from #R34271
  36616,3 Now #REGa=1 if Willy is running to the toilet, 0 otherwise
  36619,2 Flip bit 0 of #REGe if Willy is running to the toilet; this forces Willy to move right
  36621,5 Read keys Q-W-E-R-T (left, right, left, right, left) into bits 0-4 of #REGa
  36626,6 Keep only bits 0-4, shift them into bits 1-5, and set bit 0
  36632,2 Merge this keyboard reading into bits 1-5 of #REGe
  36634,4 Read keys 1-2-3-4-5 ('5' is left) and 0-9-8-7-6 (jump, nothing, right, right, left) into bits 0-4 of #REGa
  36638,3 Rotate the result right and set bits 0-2 and 4-7; this ignores every key except '5' and '6' (left)
  36641,2 Merge this reading of the '5' and '6' keys into bit 3 of #REGe
  36643,4 Read keys 0-9-8-7-6 (jump, nothing, right, right, left) into bits 0-4 of #REGa
  36647 Set bits 0, 1 and 3-7; this ignores every key except '8' (right)
  36649,2 Merge this reading of the '8' key into bit 2 of #REGe
  36651,2 Read keys 0-9-8-7-6 (jump, nothing, right, right, left) into bits 0-4 of #REGa
  36653,3 Rotate the result right and set bits 0, 1 and 3-7; this ignores every key except '7' (right)
  36656,2 Merge this reading of the '7' key into bit 2 of #REGe
  36658 Collect the Kempston joystick indicator from #R34254
  36661 Is the joystick connected?
  36662 Jump if not
  36664,5 Collect input from the joystick
  36669,3 Keep only bits 0 (right) and 1 (left) and flip them
  36672,2 Merge this reading of the joystick right and left buttons into bits 0 and 1 of #REGe
D 36674 At this point, bits 0-5 in #REGe indicate the direction in which Willy is being moved or trying to move. If bit 0, 2 or 4 is reset, Willy is being moved or trying to move right; if bit 1, 3 or 5 is reset, Willy is being moved or trying to move left.
  36674 Initialise #REGc to 0 (no movement)
  36676 Copy the movement bits into #REGa
  36677 Keep only bits 1, 3 and 5 (the 'left' bits)
  36679 Are any of these bits reset?
  36681 Jump if not
  36683 Set bit 2 of #REGc: Willy is moving left
  36685,4 Reset the inactivity timer at #R34272
  36689 Copy the movement bits into #REGa
  36690 Keep only bits 0, 2 and 4 (the 'right' bits)
  36692 Are any of these bits reset?
  36694 Jump if not
  36696 Set bit 3 of #REGc: Willy is moving right
  36698,4 Reset the inactivity timer at #R34272
  36702 Pick up the flags from #R34256
  36705,8 Point #REGhl at the entry in the left-right movement table at #R33825 that corresponds to the direction Willy is facing, and the direction in which he is being moved or trying to move
  36713 Update the flags at #R34256 with the entry from the left-right movement table
D 36717 That is left-right movement taken care of. Now check the jump keys.
  36717,5 Read keys SHIFT-Z-X-C-V and B-N-M-SS-SPACE
  36722,4 Are any of these keys being pressed?
  36726 Jump if so
  36728,4 Read keys 6-7-8-9-0
  36732 Is '0' being pressed?
  36734,2 Jump if so
  36736 Collect the Kempston joystick indicator from #R34254
  36739 Is the joystick connected?
  36740 Jump if not
  36742,5 Collect input from the joystick
  36747 Is the fire button being pressed?
  36749,2 Jump if not
D 36751 A jump key or the fire button is being pressed. Time to make Willy jump.
  36751 Pick up the game mode indicator from #R34271
  36754 Is Willy running to the toilet or does he already have his head in it?
  36756 Jump if so
  36758,4 Initialise the jumping animation counter at #R34261 to 0
  36762 Reset the inactivity timer at #R34272
  36765,4 Set the airborne status indicator at #R34257 to 1: Willy is jumping
  36769 Pick up the rope status indicator from #R34262
  36772,3 Is Willy on a rope?
  36775 Jump if not
  36777,5 Set the rope status indicator at #R34262 to 240
  36782,8 Round Willy's pixel y-coordinate at #R34255 down to the nearest multiple of 16
  36790,5 Set bit 1 at #R34256: Willy is moving
  36796 Pick up the flags from #R34256
  36799 Is Willy moving?
  36801 Return if not
  36802 Pick up the rope status indicator from #R34262
  36805,3 Is Willy on a rope?
  36808 Return if so
  36809 Pick up the flags from #R34256
  36812 Is Willy facing right?
  36814 Jump if so
D 36817 Willy is moving left.
  36817 Pick up Willy's animation frame from #R34258
  36820 Is it 0?
  36821 If so, jump to move Willy's sprite left across a cell boundary
  36823,4 Decrement Willy's animation frame at #R34258
D 36828 Willy's sprite is moving left across a cell boundary. In the comments that follow, (x,y) refers to the coordinates of the top-left cell currently occupied by Willy's sprite.
  36828,3 Pick up the airborne status indicator from #R34257
  36831 Prepare #REGbc for later addition
  36834 Is Willy jumping?
  36836 Jump if so
  36838 Collect Willy's attribute buffer coordinates from #R34259
  36841 Prepare #REGbc for later addition (again, redundantly)
  36844 Pick up the direction byte of the ramp definition for the current room from #R32986
  36847,5 Now #REGa=31 if the ramp goes up to the left, or 65 if it goes up to the right
  36852,4 Point #REGhl at the cell at (x-1,y+1) if the ramp goes up to the left, or at the cell at (x+1,y+2) if the ramp goes up to the right
  36856 Pick up the attribute byte of the ramp tile for the current room from #R32964
  36859 Is there a ramp tile in the cell pointed to by #REGhl?
  36860 Jump if not
  36862 Prepare #REGbc for later addition
  36865 Pick up the direction byte of the ramp definition for the current room from #R32986
  36868 Does the ramp go up to the right?
  36869 Jump if so
  36871 #REGbc=-32 (the ramp goes up to the left)
  36874 Collect Willy's attribute buffer coordinates from #R34259
  36877,3 Is Willy's screen x-coordinate 0 (on the far left)?
  36880,3 If so, move Willy into the room to the left
  36883,6 Point #REGhl at the cell at (x-1,y+1), or at the cell at (x-1,y) if Willy is on or approaching a ramp that goes up to the left, or at the cell at (x-1,y+2) if Willy is walking down a ramp
  36889,3 Pick up the attribute byte of the wall tile for the current room from #R32946
  36892 Is there a wall tile in the cell pointed to by #REGhl?
  36893 Return if so (Willy's path is blocked)
  36894 Pick up Willy's pixel y-coordinate (Y) from #R34255
  36897,4 Now #REGb=Y (if Willy is neither on nor approaching a ramp), or Y+16 (if Willy is walking down a ramp), or Y-16 (if Willy is on or approaching a ramp that goes up to the left); this will be Willy's new pixel y-coordinate
  36901 Is #REGb a multiple of 16?
  36903 Jump if so
  36905 Pick up the attribute byte of the wall tile for the current room from #R32946
  36908 Point #REGhl at the cell at (x-1,y+2), or at the cell at (x-1,y+1) if Willy is on or approaching a ramp that goes up to the left, or at the cell at (x-1,y+3) if Willy is on a ramp that goes up to the right
  36909 Is there a wall tile in the cell pointed to by #REGhl?
  36910 Return if so (Willy's path is blocked)
  36911,3 Point #REGhl at the cell at (x-1,y+1), or at the cell at (x-1,y) if Willy is on or approaching a ramp that goes up to the left, or at the cell at (x-1,y+2) if Willy is walking down a ramp
  36914,3 Point #REGhl at the cell at (x-1,y), or at the cell at (x-1,y-1) if Willy is on or approaching a ramp that goes up to the left, or at the cell at (x-1,y+1) if Willy is walking down a ramp
  36917 Save Willy's new attribute buffer coordinates (in #REGhl) at #R34259
  36920,4 Save Willy's new pixel y-coordinate at #R34255
  36924,5 Change Willy's animation frame at #R34258 from 0 to 3
D 36930 Willy is moving right.
  36930 Pick up Willy's animation frame from #R34258
  36933 Is it 3?
  36935 If so, jump to move Willy's sprite right across a cell boundary
  36937,4 Increment Willy's animation frame at #R34258
D 36942 Willy's sprite is moving right across a cell boundary. In the comments that follow, (x,y) refers to the coordinates of the top-left cell currently occupied by Willy's sprite.
  36942 Pick up the airborne status indicator from #R34257
  36945 Prepare #REGbc for later addition
  36948 Is Willy jumping or falling?
  36949 Jump if so
  36951 Collect Willy's attribute buffer coordinates from #R34259
  36954 Pick up the direction byte of the ramp definition for the current room from #R32986
  36957,5 Now #REGa=64 if the ramp goes up to the left, or 34 if it goes up to the right
  36962,4 Point #REGhl at the cell at (x,y+2) if the ramp goes up to the left, or at the cell at (x+2,y+1) if the ramp goes up to the right
  36966 Pick up the attribute byte of the ramp tile for the current room from #R32964
  36969 Is there a ramp tile in the cell pointed to by #REGhl?
  36970 Jump if not
  36972 Prepare #REGbc for later addition
  36975 Pick up the direction byte of the ramp definition for the current room from #R32986
  36978 Does the ramp go up to the left?
  36979 Jump if so
  36981 #REGbc=-32 (the ramp goes up to the right)
  36984 Collect Willy's attribute buffer coordinates from #R34259
  36987,3 Point #REGhl at the cell at (x+2,y), or at the cell at (x+2,y+1) if Willy is walking down a ramp, or at the cell at (x+2,y-1) if Willy is on or approaching a ramp that goes up to the right
  36990,3 Is Willy's screen x-coordinate 30 (on the far right)?
  36993 If so, move Willy into the room on the right
  36996 Prepare #REGde for addition
  36999 Pick up the attribute byte of the wall tile for the current room from #R32946
  37002 Point #REGhl at the cell at (x+2,y+1), or at the cell at (x+2,y+2) if Willy is walking down a ramp, or at the cell at (x+2,y) if Willy is on or approaching a ramp that goes up to the right
  37003 Is there a wall tile in the cell pointed to by #REGhl?
  37004 Return if so (Willy's path is blocked)
  37005 Pick up Willy's pixel y-coordinate (Y) from #R34255
  37008,4 Now #REGb=Y (if Willy is neither on nor approaching a ramp), or Y+16 (if Willy is walking down a ramp), or Y-16 (if Willy is on or approaching a ramp that goes up to the right); this will be Willy's new pixel y-coordinate
  37012 Is #REGb a multiple of 16?
  37014 Jump if so
  37016 Pick up the attribute byte of the wall tile for the current room from #R32946
  37019 Point #REGhl at the cell at (x+2,y+2), or at the cell at (x+2,y+3) if Willy is walking down a ramp, or at the cell at (x+2,y+1) if Willy is on or approaching a ramp that goes up to the right
  37020 Is there a wall tile in the cell pointed to by #REGhl?
  37021 Return if so (Willy's path is blocked)
  37022,3 Point #REGhl at the cell at (x+2,y+1), or at the cell at (x+2,y+2) if Willy is walking down a ramp, or at the cell at (x+2,y) if Willy is on or approaching a ramp that goes up to the right
  37025 Pick up the attribute byte of the wall tile for the current room from #R32946
  37028,3 Point #REGhl at the cell at (x+2,y), or at the cell at (x+2,y+1) if Willy is walking down a ramp, or at the cell at (x+2,y-1) if Willy is on or approaching a ramp that goes up to the right
  37031 Is there a wall tile in the cell pointed to by #REGhl?
  37032 Return if so (Willy's path is blocked)
  37033 Point #REGhl at the cell at (x+1,y), or at the cell at (x+1,y+1) if Willy is walking down a ramp, or at the cell at (x+1,y-1) if Willy is on or approaching a ramp that goes up to the right
  37034 Save Willy's new attribute buffer coordinates (in #REGhl) at #R34259
  37037,4 Change Willy's animation frame at #R34258 from 3 to 0
  37041,4 Save Willy's new pixel y-coordinate at #R34255
c 37046 Kill Willy
D 37046 Used by the routine at #R38430 when Willy hits a nasty.
  37046 Drop the return address from the stack
D 37047 This entry point is used by the routines at #R36564, #R37310 (when an arrow or guardian hits Willy) and #R38196 (when Willy gets too close to Maria).
  37047 Drop the return address from the stack
  37048,5 Set the airborne status indicator at #R34257 to 255 (meaning Willy has had a fatal accident)
  37053 Jump back into the main loop
c 37056 Move the rope and guardians in the current room
  37056 Point #REGix at the first byte of the entity buffer at #R33024
D 37060 The entity-moving loop begins here.
  37060 Pick up the first byte of the current entity definition
  37063 Have we reached the end of the entity buffer?
  37065 Return if so
  37066 Keep only bits 0-2 (which determine the type of entity)
  37068 Jump to consider the next entity definition if this one is an arrow or is empty
  37071 Is this a horizontal guardian?
  37073 Jump if so
  37076 Is this a vertical guardian?
  37078,3 Jump if so
D 37081 We are dealing with a rope.
  37081 Is the rope currently swinging right to left?
  37085 Jump if so
D 37087 The rope is swinging left to right.
  37087 Pick up the animation frame index
  37090 Is the rope currently swinging away from the centre?
  37092,2 Jump if so
D 37094 The rope is swinging left to right, towards the centre (132<=#REGa<=182).
  37094 Subtract 2 from the animation frame index in #REGa
  37096 Is it still 148 or greater?
  37098 If so, use it as the next animation frame index
  37100 Subtract 2 from the animation frame index again
  37102 Is it 128 now?
  37104 If not, use it as the next animation frame index
  37106 The rope has reached the centre, so the next animation frame index is 0
  37107 Jump to set it
D 37109 The rope is swinging left to right, away from the centre (0<=#REGa<=52).
  37109 Add 2 to the animation frame index in #REGa
  37111 Is it now 18 or greater?
  37113 If so, use it as the next animation frame index
  37115 Add 2 to the animation frame index again
  37117 Use this value as the next animation frame index
D 37119 The rope is swinging right to left.
  37119 Pick up the animation frame index
  37122 Is the rope currently swinging away from the centre?
  37124 Jump if so
D 37126 The rope is swinging right to left, towards the centre (4<=#REGa<=54).
  37126 Subtract 2 from the animation frame index in #REGa
  37128 Is it still 20 or greater?
  37130 If so, use it as the next animation frame index
  37132 Subtract 2 from the animation frame index again
  37134 Is it 0 now?
  37135 If not, use it as the next animation frame index
  37137 The rope has reached the centre, so the next animation frame index is 128
  37139 Jump to set it
D 37141 The rope is swinging right to left, away from the centre (128<=#REGa<=180).
  37141 Add 2 to the animation frame index in #REGa
  37143 Is it now 146 or greater?
  37145 If so, use it as the next animation frame index
  37147 Add 2 to the animation frame index again
D 37149 Now #REGa holds the rope's next animation frame index.
  37149 Update the animation frame index
  37152 Reset bit 7
  37154 Does #REGa match the eighth byte of the entity definition (54)?
  37157 If not, jump to consider the next entity definition
  37160,8 Flip bit 7 of the first byte of the entity definition: the rope has just changed direction and will now swing back towards the centre
  37168 Jump to consider the next entity definition
D 37171 We are dealing with a horizontal guardian.
  37171 Is the guardian currently moving left to right?
  37175 Jump if so
D 37177 This guardian is moving right to left.
  37177,10 Update the guardian's animation frame
  37187 Is it time to update the x-coordinate of the guardian sprite?
  37189 If not, jump to consider the next entity definition
  37191,5 Pick up the sprite's current screen x-coordinate (0-31)
  37196 Has the guardian reached the leftmost point of its path?
  37199 Jump if so
  37201 Decrement the sprite's x-coordinate
  37204 Jump to consider the next entity definition
  37206 The guardian will now start moving left to right
  37210 Jump to consider the next entity definition
D 37212 This guardian is moving left to right.
  37212,10 Update the guardian's animation frame
  37222 Is it time to update the x-coordinate of the guardian sprite?
  37224 If not, jump to consider the next entity definition
  37226,5 Pick up the sprite's current screen x-coordinate (0-31)
  37231 Has the guardian reached the rightmost point of its path?
  37234 Jump if so
  37236 Increment the sprite's x-coordinate
  37239 Jump to consider the next entity definition
  37241 The guardian will now start moving right to left
  37245 Jump to consider the next entity definition
D 37247 We are dealing with a vertical guardian.
  37247,8 Flip bit 3 of the guardian's animation frame
  37255 Are bits 3 and 4 reset?
  37257 Jump if so
  37259,8 Update the guardian's animation frame
  37267,9 Update the guardian's y-coordinate
  37276 Has the guardian reached the lowest point of its path (maximum y-coordinate)?
  37279 If so, jump to change its direction of movement
  37281 Compare the new y-coordinate with the minimum value (the highest point of its path)
  37284 If they match, jump to change the guardian's direction of movement
  37286 If the new y-coordinate is above the minimum value, jump to consider the next entity definition
  37288,6 Make sure that the guardian's y-coordinate is set to its minimum value
  37294,8 Negate the y-coordinate increment; this changes the guardian's direction of movement
D 37302 The current entity definition has been dealt with. Time for the next one.
  37302,5 Point #REGix at the first byte of the next entity definition
  37307 Jump back to deal with it
c 37310 Draw the rope, arrows and guardians in the current room
D 37310 Used by the routine at #R35245. Draws the rope, arrows and guardians in the current room to the screen buffer at 24576.
  37310 Point #REGix at the first byte of the entity buffer at #R33024
D 37314 The drawing loop begins here.
  37314 Pick up the first byte of the current entity definition
  37317 Have we reached the end of the entity buffer?
  37319 Return if so
  37320 Keep only bits 0-2 (which determine the type of entity)
  37322 Jump to consider the next entity definition if this one is empty
  37325 Is this a rope?
  37327 Jump if so
  37330 Is this an arrow?
  37332 Jump if so
D 37334 We are dealing with a horizontal or vertical guardian.
  37334,5 Point #REGde at the entry in the screen buffer address lookup table at #R33280 that corresponds to the guardian's y-coordinate
  37339,2 Copy the LSB of the screen buffer address to #REGl
  37341 Pick up the third byte of the entity definition
  37344 Keep only bits 0-4; now #REGa holds the guardian's x-coordinate
  37346,2 Adjust the LSB of the screen buffer address in #REGl for the guardian's x-coordinate
  37348 Copy the fourth byte of the entity definition to #REGa
  37349,6 #REGh=92 or 93; now #REGhl holds the address of the guardian's current location in the attribute buffer at 23552
  37355 Prepare #REGde for later addition
  37358 Pick up the second byte of the entity definition
  37361 Keep only bits 0-2 (INK colour) and 3 (BRIGHT value)
  37363 Push bit 3 up to bit 6
  37365 Keep only bits 0-2 (INK colour) and 6 (BRIGHT value)
  37367 Save this value in #REGc temporarily
  37368 Pick up the room attribute byte at the guardian's location from the buffer at 23552
  37369 Keep only bits 3-5 (PAPER colour)
  37371 Merge the INK colour and BRIGHT value from #REGc
  37372 Copy this attribute value to #REGc
  37373,7 Set the attribute bytes in the buffer at 23552 for the top two rows of cells occupied by the guardian's sprite
  37380 Pick up the fourth byte of the entity definition
  37383 Does the guardian's sprite occupy only two rows of cells at the moment?
  37385 Jump if so
  37387,4 Set the attribute bytes in the buffer at 23552 for the third row of cells occupied by the guardian's sprite
  37391 Prepare #REGc for the call to #R37974 later on
  37393,15 Point #REGde at the graphic data for the guardian's current animation frame (see #R43776)
  37408,14 Point #REGhl at the guardian's current location in the screen buffer at 24576
  37422 Draw the guardian
  37425,3 Kill Willy if the guardian collided with him
  37428 Jump to consider the next entity definition
D 37431 We are dealing with an arrow.
  37431 Is the arrow travelling left to right?
  37435 Jump if so
  37437 Decrement the arrow's x-coordinate
  37440,2 The sound effect for an arrow travelling right to left is made when the x-coordinate is 44
  37444 Increment the arrow's x-coordinate
  37447 The sound effect for an arrow travelling left to right is made when the x-coordinate is 244
  37449 Pick up the arrow's x-coordinate (0-255)
  37452 Is it time to make the arrow sound effect?
  37453 Jump if not
  37455 Prepare the delay counters (#REGb=2, #REGc=128) for the arrow sound effect
  37458 Pick up the border colour for the current room from #R32990
  37461,10 Produce the arrow sound effect
  37471 Jump to consider the next entity definition
  37474 Is the arrow's x-coordinate in the range 0-31 (i.e. on-screen)?
  37476 If not, jump to consider the next entity definition
  37479,5 Point #REGde at the entry in the screen buffer address lookup table at #R33280 that corresponds to the arrow's y-coordinate
  37484 Pick up the LSB of the screen buffer address
  37485 Adjust it for the arrow's x-coordinate
  37488,8 Point #REGhl at the arrow's current location in the attribute buffer at 23552
  37496 Initialise the collision detection byte (0=off, 255=on)
  37500 Pick up the room attribute byte at the arrow's location
  37501 Keep only bits 0-2 (INK colour)
  37503 Is the INK white?
  37505 Jump if not
  37507 Activate collision detection
  37510,4 Set the INK colour to white at the arrow's location
  37514,2 Pick up the MSB of the screen buffer address for the arrow's location
  37516,2 Point #REGhl at the top pixel row of the arrow's location in the screen buffer at 24576
  37518,4 Draw the top pixel row of the arrow
  37522 Point #REGhl at the middle pixel row of the arrow's location in the screen buffer at 24576
  37523 Pick up the graphic byte that's already here
  37524 Has the arrow hit anything that has white INK (e.g. Willy)?
  37527 If so, kill Willy
  37530 Draw the shaft of the arrow
  37532 Point #REGhl at the bottom pixel row of the arrow's location in the screen buffer at 24576
  37533,4 Draw the bottom pixel row of the arrow
  37537 Jump to consider the next entity definition
D 37540 We are dealing with a rope.
  37540 Point #REGiy at the first byte of the screen buffer address lookup table at #R33280
  37544 Initialise the second byte in the following entity definition to zero; this will count the segments of rope to draw
  37548,6 Initialise the fourth byte of the entity definition; this holds the LSB of the attribute buffer address of the segment of rope under consideration
  37554,4 Initialise the sixth byte of the entity definition to 128 (bit 7 set); the value held here is used to draw the segment of rope under consideration
D 37558 The following loop draws each segment of the rope from top to bottom.
  37558,10 Point #REGhl at the location of the segment of rope under consideration in the screen buffer at 24576
  37568 Pick up the rope status indicator at #R34262
  37571 Is Willy on the rope, or has he recently jumped or dropped off it?
  37572,2 Jump if so
  37574 Pick up the drawing byte
  37577 Is this segment of rope touching anything else that's been drawn so far (e.g. Willy)?
  37578,2 Jump if not
  37580,6 Copy the segment counter into the rope status indicator at #R34262
  37586 Signal: Willy is on the rope
  37590 Does the rope status indicator at #R34262 match the segment counter?
  37593 Jump if not
  37595 Is Willy on the rope (and clinging to this particular segment)?
  37599 Jump if not
  37601 Copy the LSB of the attribute buffer location of the segment of rope under consideration to #REGb
  37604 Pick up the drawing byte in #REGa
  37607,2 The value in #REGc will specify Willy's next animation frame; initialise it to 1
  37609 Is the set bit of the drawing byte in bit 0 or 1?
  37611 Jump if so
  37613 Assume that Willy's next animation frame will be 0
  37615 Is the set bit of the drawing byte in bit 2 or 3?
  37617 Jump if so
  37619 Decrement the LSB of the attribute buffer address, effectively moving Willy left
  37620 Assume that Willy's next animation frame will be 3
  37622 Is the set bit of the drawing byte in bit 4 or 5?
  37624 Jump if so
  37626 Willy's next animation frame will be 2 (the set bit of the drawing byte is in bit 6 or 7)
  37628,4 Set Willy's animation frame at #R34258, and the LSB of his attribute buffer address at #R34259
  37632,7 Update Willy's pixel y-coordinate at #R34255 to account for his change of location as the rope moves
  37639 Save #REGhl briefly
  37640 Update Willy's attribute buffer address at #R34259 to account for the rope's movement
  37643,1 Restore the screen buffer address of the segment of rope under consideration to #REGhl
  37644 Make a redundant jump to the next instruction
  37646,5 Draw a pixel of the rope to the screen buffer at 24576
  37651,11 Point #REGhl at the relevant entry in the second half of the rope animation table at #R33536
  37662,5 Add its value to #REGiy; now #REGiy points at the entry in the screen buffer address lookup table at #R33280 that corresponds to the next segment of rope to consider
  37667 Point #REGhl at the relevant entry in the first half of the rope animation table at #R33536
  37669 Pick up its value
  37670 Is it zero?
  37671 Jump if so
  37673 Copy the rope animation table entry value to #REGb; this will count the rotations of the drawing byte
  37674 Is the rope currently swinging from left to right?
  37678 Jump if so
  37680 Rotate the drawing byte left once
  37684 Did that push the set bit from bit 7 into bit 0?
  37688 Jump if not
  37690 Decrement the LSB of the attribute buffer address for this segment of rope
  37693 Jump back until the drawing byte has been rotated as required
  37695 Jump to consider the next segment of rope
  37697 Rotate the drawing byte right once
  37701 Did that push the set bit from bit 0 into bit 7?
  37705 Jump if not
  37707 Increment the LSB of the attribute buffer address for this segment of rope
  37710,2 Jump back until the drawing byte has been rotated as required
  37712 Pick up the segment counter
  37715 Have we drawn every segment of the rope yet?
  37718 Jump if so
  37720 Increment the segment counter
  37723 Jump back to draw the next segment of rope
D 37726 Now that the entire rope has been drawn, deal with Willy's movement along it.
  37726 Pick up the rope status indicator at #R34262
  37729 Has Willy recently jumped off the rope or dropped off the bottom of it (#REGa>=240)?
  37731 Jump if not
  37733,4 Update the rope status indicator at #R34262
  37737 Signal: Willy is not on the rope
  37741 Jump to consider the next entity definition
  37743 Is Willy on the rope?
  37747 If not, jump to consider the next entity definition
  37749 Pick up the flags from #R34256
  37752 Is Willy moving up or down the rope?
  37754 If not, jump to consider the next entity definition
  37756,5 XOR Willy's direction bit (0=facing right, 1=facing left) with the rope's direction bit (0=swinging right to left, 1=swinging left to right)
  37761,4 Now #REGa=1 if Willy is facing the same direction as the rope is swinging (he will move down the rope), or -1 otherwise (he will move up the rope)
  37765,5 Increment or decrement the rope status indicator at #R34262
  37770,4 Pick up the number of the room above from #R33003 and copy it to #REGc
  37774 Pick up the number of the current room from #R33824
  37777 Is there a room above this one?
  37778 Jump if so
  37780,1 Pick up the rope status indicator at #R34262
  37781 Is it 12 or greater?
  37783 Jump if so
  37785 Set the rope status indicator at #R34262 to 12 (there is nowhere to go above this rope)
  37787 Pick up the rope status indicator at #R34262
  37788 Compare it with the length of the rope
  37791,4 If Willy is at or above the bottom of the rope, jump to consider the next entity definition
  37795 Set the rope status indicator at #R34262 to 240 (Willy has just dropped off the bottom of the rope)
  37797,8 Clear bits 0-2 of Willy's pixel y-coordinate at #R34255
  37805,4 Initialise the airborne status indicator at #R34257
  37809 Make a redundant jump to the next instruction
D 37811 The current entity definition has been dealt with. Time for the next one.
  37811,5 Point #REGix at the first byte of the next entity definition
  37816 Jump back to deal with it
u 37819 Unused routine
D 37819 This routine is not used, but if it were, it would set the ink colour for a 3x2 block of cells, maintaining the paper, bright and flash attributes of the current room background.
R 37819 A INK colour (0-7)
R 37819 HL Attribute file or attribute buffer address
C 37819 Store the ink colour (bits 0-2)
C 37820 Collect the current room's background tile attribute from #R32928
C 37823 Keep only bits 3-7 (PAPER, BRIGHT, FLASH)
C 37825 Merge the INK bits
C 37826 Store the resultant attribute byte
C 37827 Prepare #REGde for later addition
C 37830,2 Move right one cell and store the attribute byte there
C 37832,2 Move left one cell and down a row and store the attribute byte there
C 37834,2 Move right one cell and store the attribute byte there
C 37836,2 Move left one cell and down a row and store the attribute byte there
C 37838,2 Move right one cell and store the attribute byte there
C 37840
c 37841 Draw the items in the current room and collect any that Willy is touching
  37841 Page #R41984(164) holds the first byte of each entry in the item table
  37843 Pick up the index of the first item from #R41983
  37846 Point #REGhl at the first byte of the first entry in the item table
D 37847 The item-drawing loop begins here.
  37847 Pick up the first byte of the current entry in the item table
  37848 Reset bit 7; bit 6 holds the collection flag, and bits 0-5 hold the room number
  37850 Pick up the number of the current room from #R33824
  37853 Set bit 6 (corresponding to the collection flag)
  37855 Is the item in the current room and still uncollected?
  37856 If not, jump to consider the next entry in the item table
  37858 Pick up the first byte of the current entry in the item table
D 37858 This item is in the current room and has not been collected yet.
  37859,9 Point #REGde at the location of the item in the attribute buffer at 23552
  37868 Pick up the item's current attribute byte
  37869,4 Is the INK white (which can happen only if Willy is touching the item)?
  37873 Jump if not
D 37875 Willy is touching this item, so add it to his collection.
  37875 Point #REGix at the number of items collected at #R34172
  37879 Increment a digit of the number of items collected
  37882,5 Was the digit originally '9'?
  37887 Jump if not
  37889 Set the digit to '0'
  37893 Move back to the digit on the left
  37895 Jump back to increment this digit
  37897 Pick up the border colour for the current room from #R32990
  37900,18 Produce the sound effect for collecting an item
  37918,7 Update the counter of items remaining at #R34270, and set the zero flag if there are no more items to collect
  37925 Jump if there are any items still to be collected
  37927,5 Update the game mode indicator at #R34271 to 1 (all items collected)
  37932 Reset bit 6 of the first byte of the entry in the item table, indicating that the item has been collected
  37934 Jump to consider the next entry in the item table
D 37936 Willy is not touching this item, so draw it and cycle its INK colour.
  37936,9 Generate the INK colour for the item from the value of the minute counter at #R34251 (0-255) and the index of the item in the item table (173-255)
  37945,5 Change the INK colour of the item in the attribute buffer at 23552
  37950,10 Point #REGde at the location of the item in the screen buffer at 24576
  37960 Save #REGhl briefly
  37961 Point #REGhl at the item graphic for the current room (at #R32993)
  37964 There are eight pixel rows to copy
  37966 Draw the item to the screen buffer at 24576
  37969 Restore the item table pointer to #REGhl
D 37970 The current item has been dealt with (skipped, collected or drawn) as appropriate. Time to consider the next one.
  37970 Point #REGhl at the first byte of the next entry in the item table
  37971,2 Jump back unless we've examined every entry
c 37974 Draw a sprite
D 37974 Used by the routines at #R34499 (to draw the number key graphics on the code entry screen), #R35211 (to draw the remaining lives), #R35914 (to draw Willy, the boot and the barrel during the game over sequence), #R37310 (to draw guardians in the current room) and #R38196 (to draw Maria in #R58112(Master Bedroom)). If #REGc=1 on entry, this routine returns with the zero flag reset if any of the set bits in the sprite being drawn collides with a set bit in the background.
R 37974 C Drawing mode: 0 (overwrite) or 1 (blend)
R 37974 DE Address of sprite graphic data
R 37974 HL Address to draw at
  37974 There are 16 rows of pixels to draw
  37976 Set the zero flag if we're in overwrite mode
  37978 Pick up a sprite graphic byte
  37979 Jump if we're in overwrite mode
  37981,2 Return with the zero flag reset if any of the set bits in the sprite graphic byte collide with a set bit in the background (e.g. in Willy's sprite)
  37983 Pick up the sprite graphic byte again
  37984 Blend it with the background byte
  37985 Copy the graphic byte to its destination cell
  37986 Move #REGhl along to the next cell on the right
  37987 Point #REGde at the next sprite graphic byte
  37988 Set the zero flag if we're in overwrite mode
  37990 Pick up a sprite graphic byte
  37991 Jump if we're in overwrite mode
  37993,2 Return with the zero flag reset if any of the set bits in the sprite graphic byte collide with a set bit in the background (e.g. in Willy's sprite)
  37995 Pick up the sprite graphic byte again
  37996 Blend it with the background byte
  37997 Copy the graphic byte to its destination cell
  37998,2 Move #REGhl to the next pixel row down in the cell on the left
  38000 Point #REGde at the next sprite graphic byte
  38001,3 Have we drawn the bottom pixel row in this pair of cells yet?
  38004 Jump if not
  38006,8 Otherwise move #REGhl to the top pixel row in the cell below
  38014 Was the last pair of cells at y-coordinate 7 or 15?
  38016 Jump if not
  38018,4 Otherwise adjust #REGhl to account for the movement from the top or middle third of the screen to the next one down
  38022 Jump back until all 16 rows of pixels have been drawn
  38024,1 Set the zero flag (to indicate no collision)
c 38026 Move Willy into the room to the left
  38026 Pick up the number of the room to the left from #R33001
  38029 Make it the current room number by copying it to #R33824
  38032,10 Adjust Willy's screen x-coordinate (at #R34259) to 30 (on the far right)
  38042 Drop the return address (#R35281, in the main loop) from the stack
  38043 Draw the room and re-enter the main loop
c 38046 Move Willy into the room to the right
  38046 Pick up the number of the room to the right from #R33002
  38049 Make it the current room number by copying it to #R33824
  38052,8 Adjust Willy's screen x-coordinate (at #R34259) to 0 (on the far left)
  38060 Drop the return address (#R35281, in the main loop) from the stack
  38061 Draw the room and re-enter the main loop
c 38064 Move Willy into the room above
  38064 Pick up the number of the room above from #R33003
  38067 Make it the current room number by copying it to #R33824
  38070,15 Willy should now appear on the bottom floor of the room, so adjust his coordinates (at #R34259) accordingly
  38085,5 Set Willy's pixel y-coordinate (at #R34255) to 208
  38090,4 Reset the airborne status indicator at #R34257
  38094 Drop the return address (either #R35281 or #R35289, in the main loop) from the stack
  38095 Draw the room and re-enter the main loop
c 38098 Move Willy into the room below
  38098 Pick up the number of the room below from #R33004
  38101 Make it the current room number by copying it to #R33824
  38104,4 Set Willy's pixel y-coordinate (at #R34255) to 0
  38108 Pick up the airborne status indicator from #R34257
  38111 Is it 11 or greater?
  38113 Jump if so
  38115,5 Otherwise set the airborne status indicator to 2
  38120,13 Willy should now appear at the top of the room, so adjust his coordinates (at #R34259) accordingly
  38133 Drop the return address (#R35281, in the main loop) from the stack
  38134 Draw the room and re-enter the main loop
c 38137 Move the conveyor in the current room
  38137 Pick up the coordinates of the left end of the conveyor
  38140,11 Point #REGde and #REGhl at the location of the left end of the conveyor in the screen buffer at 28672
  38151 Pick up the length of the conveyor
  38154 Is there a conveyor in the room?
  38155 Return if not
  38156 #REGb will count the conveyor tiles
  38157 Pick up the direction of the conveyor (0=left, 1=right)
  38160 Is the conveyor moving right?
  38161 Jump if so
D 38163 The conveyor is moving left.
  38163 Copy the first pixel row of the conveyor tile to #REGa
  38164,4 Rotate it left twice
  38168,2 Point #REGhl at the third pixel row of the conveyor tile
  38170 Copy this pixel row to #REGc
  38171,4 Rotate it right twice
  38175,6 Update the first and third pixel rows of every conveyor tile in the screen buffer at 28672
D 38182 The conveyor is moving right.
  38182 Copy the first pixel row of the conveyor tile to #REGa
  38183,4 Rotate it right twice
  38187,2 Point #REGhl at the third pixel row of the conveyor tile
  38189 Copy this pixel row to #REGc
  38190,4 Rotate it left twice
  38194 Jump back to update the first and third pixel rows of every conveyor tile
c 38196 Deal with special rooms (Master Bedroom, The Bathroom)
  38196 Pick up the number of the current room from #R33824
  38199 Are we in #R58112(Master Bedroom)?
  38201 Jump if not
  38203 Pick up the game mode indicator from #R34271
  38206 Has Willy collected all the items?
  38207 Jump if so
D 38209 Willy hasn't collected all the items yet, so Maria is on guard.
  38209 Pick up the minute counter from #R34251; this will determine Maria's animation frame
  38212,8 Keep only bit 1, move it to bit 5, and set bit 7
  38220 Now #REGe=128 (foot down) or 160 (foot raised)
  38221 Pick up Willy's pixel y-coordinate from #R34255
  38224 Is Willy on the floor below the ramp?
  38226 Jump if so
  38228 #REGe=192 (raising arm)
  38230 Is Willy on the ramp?
  38232 Jump if so
  38234 #REGe=224 (arm raised)
  38236 Point #REGde at the sprite graphic data (#R40064, #R40096, #R40128 or #R40160)
  38238,8 Draw Maria at (11,14) in the screen buffer at 24576
  38246,3 Kill Willy if Maria collided with him
  38249 #REGh=#REGl=69 (INK 5: PAPER 0: BRIGHT 1)
  38252 Set the attribute bytes for the top half of Maria's sprite in the buffer at 23552
  38255 #REGh=#REGl=7 (INK 7: PAPER 0: BRIGHT 0)
  38258,3 Set the attribute bytes for the bottom half of Maria's sprite in the buffer at 23552
D 38262 Willy has collected all the items, so Maria is gone.
  38262,5 Pick up Willy's screen x-coordinate from #R34259
  38267 Has Willy reached the bed (at x=5) yet?
  38269 Return if not
  38270,5 Update the game mode indicator at #R34271 to 2 (Willy is running to the toilet)
c 38276 Check whether Willy has reached the toilet
D 38276 Called by the routine at #R35245 when Willy is on his way to the toilet.
  38276 Pick up the number of the current room from #R33824
  38279 Are we in #R57600(The Bathroom)?
  38281 Return if not
  38282 Pick up Willy's coordinates from #R34259
  38285 Is Willy's screen x-coordinate 28 (where the toilet is)?
  38287 Return if not
D 38288 Willy has reached the toilet.
  38288,4 Reset the minute counter at #R34251 to 0
  38292,5 Update the game mode indicator at #R34271 to 3 (Willy's head is down the toilet)
c 38298 Animate the toilet in The Bathroom
  38298 Pick up the number of the current room from #R33824
  38301 Are we in #R57600(The Bathroom)?
  38304 Pick up the minute counter from #R34251; this will determine the animation frame to use for the toilet
  38307,5 Keep only bit 0 and move it to bit 5
  38312 Now #REGe=0 or 32
  38313 Pick up the game mode indicator from #R34271
  38316 Is Willy's head down the toilet?
  38318 Jump if not
  38320 Now #REGe=64 or 96
  38322 Point #REGde at the sprite to use (#R42496, #R42528, #R42560 or #R42592)
  38324,10 Draw the toilet at (13,28) in the screen buffer at 24576
  38334 #REGh=#REGl=7 (INK 7: PAPER 0)
  38337,6 Set the attribute bytes for the toilet in the buffer at 23552
  38303 Return if not
c 38344 Check and set the attribute bytes for Willy's sprite in the buffer at 23552
D 38344 Used by the routine at #R35245. Sets the attribute bytes in the buffer at 23552 for the six cells (in three rows of two) occupied by or under Willy's sprite, or kills Willy if any of the cells contains a nasty.
  38344 Pick up Willy's coordinates in the attribute buffer at 23552 from #R34259
  38347 Initialise #REGb to 0 (in case Willy is not standing on a ramp)
  38349 Pick up the direction byte of the ramp definition for the current room from #R32986
  38352,8 Point #REGhl at one of the cells under Willy's feet (the one on the left if the ramp goes up to the left, the one on the right if the ramp goes up to the right)
  38360 Pick up the ramp's attribute byte from #R32964
  38363 Is Willy on or just above the ramp?
  38364 Jump if not
  38366 Pick up the airborne status indicator from #R34257
  38369 Is Willy airborne?
  38370 Jump if so
D 38372 Willy is standing on a ramp. Calculate the offset that needs to be added to the y-coordinate stored at #R34255 to obtain Willy's true pixel y-coordinate.
  38372 Pick up Willy's current animation frame (0-3) from #R34258
  38375,5 #REGb=0, 4, 8 or 12
  38380 Pick up the direction byte of the ramp definition for the current room from #R32986
  38383,8 #REGa=#REGb (if the ramp goes up to the left) or 12-#REGb (if the ramp goes up to the right)
  38391 Copy this value to #REGb
D 38392 Now #REGb holds a y-coordinate offset of 0, 4, 8 or 12 if Willy is standing on a ramp, or 0 otherwise.
  38392 Pick up Willy's coordinates in the attribute buffer at 23552 from #R34259
  38395,3 Prepare #REGde for later addition
  38398 Set #REGc=15 for the top two rows of cells (to make the routine at #R38430 force white INK)
  38400 Check and set the attribute byte for the top-left cell
  38403 Move #REGhl to the next cell to the right
  38404 Check and set the attribute byte for the top-right cell
  38407 Move #REGhl down a row and back one cell to the left
  38408 Check and set the attribute byte for the mid-left cell
  38411 Move #REGhl to the next cell to the right
  38412 Check and set the attribute byte for the mid-right cell
  38415,3 Pick up Willy's pixel y-coordinate from #R34255
  38418,2 Add the y-coordinate offset calculated earlier (to get Willy's true pixel y-coordinate if he's standing on a ramp) and transfer the result to #REGc
  38420 Move #REGhl down a row and back one cell to the left
  38421 Check and set the attribute byte for the bottom-left cell
  38424 Move #REGhl to the next cell to the right
  38425 Check and set the attribute byte for the bottom-right cell
  38428 Draw Willy to the screen buffer at 24576
c 38430 Check and set the attribute byte for a cell occupied by Willy's sprite
D 38430 Used by the routine at #R38344. Sets the attribute byte in the buffer at 23552 for one of the six cells (in three rows of two) occupied by or under Willy's sprite, or kills Willy if the cell contains a nasty. On entry, #REGc holds either 15 if the cell is in the top two rows, or Willy's pixel y-coordinate if the cell is in the bottom row.
R 38430 C 15 or Willy's pixel y-coordinate
R 38430 HL Address of the attribute byte in the buffer at 23552
  38430 Pick up the attribute byte of the background tile in the current room from #R32928
  38433 Does this cell contain a background tile?
  38434 Jump if not
  38436,3 Set the zero flag if we are going to retain the INK colour in this cell; this happens only if the cell is in the bottom row and Willy's pixel y-coordinate is a multiple of 16
  38439 Jump if we are going to retain the current INK colour in this cell
  38441 Pick up the attribute byte of the background tile in the current room from #R32928
  38444 Set bits 0-2, making the INK white
  38446 Set the attribute byte for this cell in the buffer at 23552
  38447 Pick up the attribute byte of the nasty tile in the current room from #R32955
  38450 Has Willy hit a nasty?
  38451,3 Kill Willy if so
c 38455 Draw Willy to the screen buffer at 24576
R 38455 B y-coordinate offset (0, 4, 8 or 12)
  38455 Pick up Willy's pixel y-coordinate from #R34255
  38458 Add the y-coordinate offset (to get Willy's true pixel y-coordinate if he's standing on a ramp)
  38459,5 Point #REGix at the entry in the screen buffer address lookup table at #R33280 that corresponds to Willy's y-coordinate
  38464 Pick up the flags from #R34256
  38467,4 Now #REGe=0 if Willy is facing right, or 128 if he's facing left
  38471 Pick up Willy's animation frame from #R34258
  38474,9 Point #REGde at the sprite graphic data for Willy's current animation frame (#R40192, #R40224, #R40256, #R40288, #R40320, #R40352, #R40384 or #R40416)
  38483 Pick up the number of the current room from #R33824
  38486 Are we in the #R56576(The Nightmare Room)?
  38488 Jump if not
  38490 Point #REGde at the graphic data for the flying pig sprite (#R46592, #R46624, #R46656, #R46688, #R46720, #R46752, #R46784 or #R46816)
  38496 There are 16 rows of pixels to copy
  38498,5 Pick up Willy's screen x-coordinate (0-31) from #R34259
  38503 Copy it to #REGc
D 38504 This entry point is used by the routine at #R38298 to draw the toilet in #R57600(The Bathroom).
  38504,8 Set #REGhl to the address in the screen buffer at 24576 that corresponds to the location of the sprite graphic tile we are going to draw
  38512 Pick up a sprite graphic byte
  38513 Merge it with the background
  38514 Save the resultant byte to the screen buffer
  38515 Move #REGhl along to the next cell to the right
  38516 Point #REGde at the next sprite graphic byte
  38517 Pick it up in #REGa
  38518 Merge it with the background
  38519 Save the resultant byte to the screen buffer
  38520,4 Point #REGix at the next entry in the screen buffer address lookup table at #R33280
  38524 Point #REGde at the next sprite graphic byte
  38525,2 Jump back until all 16 rows of pixels have been drawn
c 38528 Print a message
R 38528 IX Address of the message
R 38528 C Length of the message
R 38528 DE Display file address
  38528 Collect a character from the message
  38531 Print it
  38534 Point #REGix at the next character in the message
  38536,5 Point #REGde at the next character cell (subtracting 8 from #REGd compensates for the operations performed by the routine at #R38545)
  38541 Have we printed the entire message yet?
  38542,2 If not, jump back to print the next character
c 38545 Print a single character
R 38545 A ASCII code of the character
R 38545 DE Display file address
  38545,8 Point #REGhl at the bitmap for the character (in the ROM)
  38553 There are eight pixel rows in a character bitmap
D 38555 This entry point is used by the routine at #R34762 to draw a triangle UDG on the title screen, and by the routine at #R37841 to draw an item in the current room.
  38555,6 Copy the character bitmap (or triangle UDG, or item graphic) to the screen (or screen buffer)
c 38562 Play the theme tune
D 38562 Used by the routine at #R34762. For each of the 99 bytes in the tune data table at #R34299, this routine produces two notes, each lasting approximately 0.15s; the second note is played at half the frequency of the first. Returns with the zero flag reset if ENTER, 0 or the fire button is pressed while the tune is being played.
R 38562 HL #R34299
  38562 Pick up the next byte of tune data from the table at #R34299
  38563 Has the tune finished?
  38565 Return (with the zero flag set) if so
  38566 #REGb=0 (short note duration counter), #REGc=100 (short note counter)
  38569 #REGa=0 (border colour and speaker state)
  38570 Save the byte of tune data in #REGe for retrieval during the short note loop
  38571 Initialise #REGd (pitch delay counter)
  38572,10 Produce a short note (approximately 0.003s) whose pitch is determined by the value in #REGe
  38582 Save #REGa briefly
  38583,3 Is the short note counter in #REGc (which starts off at 100) down to 50 yet?
  38586 Jump if not
  38588 Otherwise double the value in #REGe (which halves the note frequency)
  38590 Restore the value of #REGa
  38591 Decrement the short note counter in #REGc
  38592 Jump back unless we've finished playing 50 short notes at the lower frequency
  38594 Check whether ENTER, 0 or the fire button is being pressed
  38597 Return (with the zero flag reset) if it is
  38598 Move #REGhl along to the next byte of tune data
  38599 Jump back to play the next batch of 100 short notes
c 38601 Check whether ENTER, 0 or the fire button is being pressed
D 38601 Used by the routine at #R38562. Returns with the zero flag reset if ENTER, 0 or the fire button on the joystick is being pressed.
  38601 Collect the Kempston joystick indicator from #R34254
  38604 Is the joystick connected?
  38605 Jump if not
  38607 Collect input from the joystick
  38609 Is the fire button being pressed?
  38611 Return (with the zero flag reset) if so
  38612,5 Read keys H-J-K-L-ENTER and 6-7-8-9-0
  38617 Keep only bit 0 of the result (ENTER, 0)
  38619,2 Reset the zero flag if ENTER or 0 is being pressed
c 38622 Play an intro message sound effect
R 38622 A Value between 50 and 81
  38622 Save the value of #REGa in #REGe for later retrieval
  38623 We will output to port 254
  38625 Copy #REGa into #REGd; bits 0-2 of #REGd determine the initial border colour
  38626 Reset bit 4 of #REGd (initial speaker state)
  38628 Reset bit 3 of #REGd (initial MIC state)
  38630,1 Initialise #REGb (delay counter for the inner loop)
  38631 Is it time to flip the MIC and speaker and make the border black?
  38632 Jump if not
  38634 Set bits 3 (MIC) and 4 (speaker) of #REGd, and reset bits 0-2 (black border)
  38636 Set the MIC state, speaker state and border colour
  38638 Jump back until the inner loop is finished
  38640 Is the outer loop finished too?
  38641,2 Jump back if not
u 38644 Unused routine
C 38644,11 Copy the attribute buffer at 24064 to the top two-thirds of the screen
C 38655,13 Fill the top two-thirds of the display file with the byte value 24 (00011000)
C 38668 Prepare #REGbc for reading keys SHIFT-Z-X-C-V
C 38671 Read these keys
C 38673 Is 'X' being pressed?
C 38675 Jump if so to reset the machine
C 38678 Otherwise jump back to read the keyboard again
s 38680
b 38912 Attributes for the top two-thirds of the title screen
D 38912 Used by the routine at #R34762.
B 38912,512,16
b 39424 Attributes for the bottom third of the screen during gameplay
D 39424 Used by the routines at #R35068 and #R35591.
B 39424,256,16
b 39680 Number key graphics
D 39680 Used by the routine at #R34499.
D 39680 #UDGTABLE {{ #UDGARRAY2,65,,2;39680;39681,121;39696;39697(number_key0) | #UDGARRAY2,66,,2;39712;39713,122;39728;39729(number_key1) | #UDGARRAY2,3,,2;39744;39745,59;39760;39761(number_key2) | #UDGARRAY2,4,,2;39776;39777,60;39792;39793(number_key3) }} TABLE#
B 39680,128,16
b 39808 Attributes for the code entry screen
D 39808 Used by the routine at #R34499.
B 39808,128,16
u 39936 Source code remnants
D 39936 The source code here corresponds to the code at #R35545.
T 39936 [JR ]NZ,ENDPAUSE
M 39947,9 INC E
W 39947
B 39949
T 39950,6,B1:3:B1:1
M 39956,15 JR NZ,PAUSE
W 39956
B 39958
T 39959,12,B1:2:B1:8
M 39971,9 INC D
W 39971
B 39973
T 39974,6,B1:3:B1:1
M 39980,15 JR NZ,PAUSE
W 39980
B 39982
T 39983,12,B1:2:B1:8
M 39995,5 C[P 10]
W 39995
B 39997
T 39998,2,B1:1
b 40000 Foot/barrel graphic data
D 40000 Used by the routine at #R35914 to display the game over sequence.
D 40000 The foot also appears as a guardian in #R56576(The Nightmare Room).
{foot}
D 40032 The barrel also appears as a guardian in #R54272(Ballroom East) and #R57856(Top Landing).
{barrel}
b 40064 Maria sprite graphic data
D 40064 Used by the routine at #R38196 to draw Maria in #R58112(Master Bedroom).
D 40064 Maria also appears as a guardian in #R56576(The Nightmare Room).
{maria}
b 40192 Willy sprite graphic data
D 40192 Used by the routines at #R35211 and #R38455.
{willy}
b 40448 Codes
D 40448 Used by the routine at #R34499.
{codes}
u 40627
C 40627
S 40704
b 40960 Entity definitions
D 40960 Used by the routine at #R35068.
{entity_defs}
D 41856 The next 127 bytes are unused.
B 41856,127,16
b 41983 Index of the first item
D 41983 Used by the routines at #R34762 and #R37841.
b 41984 Item table
D 41984 Used by the routines at #R34762 and #R37841.
D 41984 The location of item N (173<=N<=255) is defined by the pair of bytes at addresses 41984+N and 42240+N. The meaning of the bits in each byte-pair is as follows:
D 41984 #TABLE(default,centre) {{ =h Bit(s) | =h Meaning }} {{ 15 | Most significant bit of the y-coordinate }} {{ 14 | Collection flag (reset=collected, set=uncollected) }} {{ 8-13 | Room number }} {{ 5-7 | Least significant bits of the y-coordinate }} {{ 0-4 | x-coordinate }} TABLE#
{item_table}
b 42496 Toilet graphics
D 42496 Used by the routine at #R38298.
{toilet}
u 42624
B 42624,128,16
S 42752
b 43776 Guardian graphics
D 43776 Used by the routine at #R37310.
{guardians}
{rooms}
u 64768 Unused TRS-DOS code
C 64768
B 65005,136,16
T 65141
C 65147
B 65203,2
T 65205
C 65236
B 65410,16,8
C 65426
S 65517
